{"ast":null,"code":"var AbiCoder = require('./abi-coder/index'); // const compile = require('./compile/index')//compile.js\n\n\nvar compile = require('./compile/crc20'); //compile.js\n\n/**\n * \n * @param {*} Params \n * @param {*} abiObj \n * @returns \n */\n\n\nfunction parse(Params, abiObj) {\n  var funABI = '';\n\n  if (!abiObj) {\n    var functionName = Params.functionName;\n    var abi = abiObj || compile.abi;\n    var args = Params.args ? Params.args : [];\n\n    for (var i in abi) {\n      var name = void 0;\n\n      if (abi[i].name === undefined) {\n        name = abi[i].type;\n      } else {\n        name = abi[i].name;\n      }\n\n      if (name === functionName) {\n        funABI = abi[i];\n        break;\n      }\n    }\n\n    Params.funABI = funABI;\n    var types = [];\n\n    if (funABI.inputs && funABI.inputs.length) {\n      for (var _i = 0; _i < funABI.inputs.length; _i++) {\n        var type = funABI.inputs[_i].type;\n        types.push(type);\n\n        if (args.length < types.length) {\n          args.push('');\n        }\n      }\n    }\n\n    var abiCoder = new AbiCoder();\n    var paramsEncode = abiCoder.encode(types, args);\n    paramsEncode = paramsEncode.substr(0, 2) === \"0x\" ? paramsEncode.substr(2) : paramsEncode;\n\n    if (funABI.name === \"constructor\" || funABI.type === \"constructor\") {\n      Params.data = compile.contractByteCode + paramsEncode;\n    } else {\n      var methodBytecode = compile.methodBytecode;\n      Params.data = methodBytecode[functionName] + paramsEncode;\n    }\n\n    return Params;\n  } else {\n    funABI = abiObj;\n    var _args = Params.funArgs;\n    var _types = [];\n\n    if (funABI.inputs && funABI.inputs.length) {\n      for (var _i2 = 0; _i2 < funABI.inputs.length; _i2++) {\n        var _type = funABI.inputs[_i2].type;\n\n        _types.push(_type.indexOf('tuple') === 0 ? makeFullTupleTypeDefinition(funABI.inputs[_i2]) : _type);\n\n        if (_args.length < _types.length) {\n          _args.push('');\n        }\n      }\n    } // NOTE: the caller will concatenate the bytecode and this\n    //       it could be done here too for consistency\n\n\n    return new AbiCoder().encode(_types, _args);\n  }\n  /**\n   * \n   * @param {*} typeDef \n   * @returns \n   */\n\n\n  function makeFullTupleTypeDefinition(typeDef) {\n    if (typeDef && typeDef.type.indexOf('tuple') === 0 && typeDef.components) {\n      var innerTypes = typeDef.components.map(function (innerType) {\n        return innerType.type;\n      });\n      return \"tuple(\".concat(innerTypes.join(','), \")\").concat(this.extractSize(typeDef.type));\n    }\n\n    return typeDef.type;\n  }\n}\n\nmodule.exports = {\n  parse: parse\n};","map":null,"metadata":{},"sourceType":"script"}