{"ast":null,"code":"var BigNumber = require('bignumber.js').default;\n\nvar Hash = require(\"./lib/hash\");\n\nvar decode = require(\"./helper/decode\");\n\nvar encode = require(\"./helper/encode\");\n\nvar secp256k1 = require('secp256k1');\n\nvar _require = require(\"./helper/abi-coder/address\"),\n    getAddress = _require.getAddress;\n\nvar _require2 = require(\"./helper/abi-coder/convert\"),\n    arrayify = _require2.arrayify;\n\nvar _require3 = require('js-sha3'),\n    keccak256 = _require3.keccak256;\n\nvar sha256 = require(\"js-sha256\");\n\nvar unitMap = {\n  'none': '0',\n  'None': '0',\n  'can': '1',\n  'Can': '1',\n  'mcp': '1000000000000000000',\n  'MCP': '1000000000000000000'\n};\n/**\r\n * Encode an account\r\n * @param {string} publicKey \r\n * @returns {string}\r\n */\n\nvar encodeAccount = function encodeAccount(publicKey) {\n  // Zero address, special treatment\n  if (publicKey === \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\") {\n    return \"mcp_zero_address\";\n  }\n\n  var pub = '0x' + publicKey;\n  var newBytes = arrayify(pub);\n  var kh = keccak256(newBytes);\n  var account = \"0x\" + kh.substring(24);\n  var result = getAddress(account);\n  return result;\n};\n\nvar toUint8Array = function toUint8Array(hexString) {\n  return new Uint8Array(hexString.match(/.{1,2}/g).map(function (byte) {\n    return parseInt(byte, 16);\n  }));\n};\n/**\r\n * Determine whether the input parameter is a string\r\n * @param {*} obj \r\n * @returns {boolean}\r\n */\n\n\nvar isString = function isString(obj) {\n  return typeof obj === 'string' && obj.constructor === String;\n};\n/**\r\n * Determine whether the input parameter is BigNumber\r\n * @param {*} object \r\n * @returns {boolean}\r\n */\n\n\nvar isBigNumber = function isBigNumber(object) {\n  return object && object.constructor && object.constructor.name === 'BigNumber';\n};\n/**\r\n * Number to BigNumber\r\n * @param {number | BigNumber | string} number \r\n * @returns {number | BigNumber} \r\n */\n\n\nvar toBigNumber = function toBigNumber(number) {\n  number = number || 0;\n\n  if (isBigNumber(number)) {\n    return number;\n  }\n\n  if (isString(number) && (number.indexOf('0x') === 0 || number.indexOf('-0x') === 0)) {\n    return new BigNumber(number.replace('0x', ''), 16);\n  }\n\n  return new BigNumber(number.toString(10), 10);\n};\n/**\r\n * Get the value of the unit\r\n * @param {string} unit \r\n * @returns {BigNumber | Error}\r\n */\n\n\nvar getValueOfUnit = function getValueOfUnit(unit) {\n  unit = unit ? unit.toLowerCase() : 'mcp';\n  var unitValue = unitMap[unit];\n\n  if (unitValue === undefined) {\n    throw new Error('This unit doesn\\'t exists, please use the one of the following units' + JSON.stringify(unitMap, null, 2));\n  }\n\n  return new BigNumber(unitValue, 10);\n};\n/**\r\n * \r\n * @param {number} number \r\n * @param {string} unit \r\n * @returns \r\n */\n\n\nvar fromCan = function fromCan(number, unit) {\n  var returnValue = toBigNumber(number).dividedBy(getValueOfUnit(unit));\n  return isBigNumber(number) ? returnValue : returnValue.toString(10);\n};\n/**\r\n * \r\n * @param {number} number \r\n * @param {string} precision \r\n * @returns \r\n */\n\n\nvar fromCanToken = function fromCanToken(number, precision) {\n  var returnValue = toBigNumber(number).dividedBy(precision);\n  return isBigNumber(number) ? returnValue : returnValue.toString(10);\n};\n/**\r\n * \r\n * @param {number} number \r\n * @param {string} unit \r\n * @returns \r\n */\n\n\nvar toCan = function toCan(number, unit) {\n  var returnValue = toBigNumber(number).times(getValueOfUnit(unit));\n  return isBigNumber(number) ? returnValue : returnValue.toString(10);\n};\n/**\r\n * \r\n * @param {number} number \r\n * @param {string} precision \r\n * @returns \r\n */\n\n\nvar toCanToken = function toCanToken(number, precision) {\n  var returnValue = toBigNumber(number).times(precision);\n  return isBigNumber(number) ? returnValue : returnValue.toString(10);\n};\n/**\r\n * Determine whether the account is legal\r\n * @param {*} act \r\n * @returns {boolean}\r\n */\n\n\nvar isAccount = function isAccount(act) {\n  if (!act) {\n    return false;\n  }\n\n  return true;\n};\n/**\r\n * Determine the data type\r\n * @param {any} data \r\n * @returns \r\n */\n\n\nvar judge = function judge(data) {\n  var value = /\\[object (\\w+)\\]/.exec(Object.prototype.toString.call(data));\n  return value ? value[1].toLowerCase() : '';\n};\n/**\r\n * Handling errors\r\n * @param {*} error \r\n * @param {*} emitter \r\n * @param {*} reject \r\n * @param {Function} callback \r\n * @returns \r\n */\n\n\nvar _fireError = function _fireError(error, emitter, reject, callback) {\n  // add data if given\n  if (judge(error) === 'object' && !(error instanceof Error) && error.data) {\n    if (judge(error.data) === 'object' || judge(error.data) === 'array') {\n      error.data = JSON.stringify(error.data, null, 2);\n    }\n\n    error = error.message + \"\\n\" + error.data;\n  }\n\n  if (judge(error) === 'string') {\n    error = new Error(error);\n  }\n\n  if (judge(callback) === 'function') {\n    callback(error);\n  }\n\n  if (judge(reject) === 'function') {\n    if (emitter && judge(emitter.listeners) === 'function' && emitter.listeners('error').length || judge(callback) === 'function') {\n      emitter.catch(function () {});\n    }\n\n    setTimeout(function () {\n      reject(error);\n    }, 1);\n  }\n\n  if (emitter && judge(emitter.emit) === 'function') {\n    // emit later, to be able to return emitter\n    setTimeout(function () {\n      emitter.emit('error', error);\n      emitter.removeAllListeners();\n    }, 1);\n  }\n\n  return emitter;\n};\n/**\r\n * Interface to string\r\n * @param {*} json \r\n * @returns \r\n */\n\n\nvar _jsonInterfaceMethodToString = function _jsonInterfaceMethodToString(json) {\n  // Is an object, and has a json name, and is a function\n  if (judge(json) === 'object' && json.name && json.name.indexOf('(') !== -1) {\n    return json.name;\n  }\n\n  return json.name + '(' + _flattenTypes(false, json.inputs).join(',') + ')';\n};\n/**\r\n * \r\n * @param {*} includeTuple \r\n * @param {*} puts \r\n * @returns \r\n */\n\n\nvar _flattenTypes = function _flattenTypes(includeTuple, puts) {\n  var types = [];\n  puts.forEach(function (param) {\n    if (judge(param.components) === 'object') {\n      if (param.type.substring(0, 5) !== 'tuple') {\n        throw new Error('components found but type is not tuple; report on GitHub');\n      }\n\n      var suffix = '';\n      var arrayBracket = param.type.indexOf('[');\n\n      if (arrayBracket >= 0) {\n        suffix = param.type.substring(arrayBracket);\n      }\n\n      var result = _flattenTypes(includeTuple, param.components); // console.log(\"result should have things: \" + result)\n      // ! TODO error \n\n\n      if (judge(param.data) === 'array' && includeTuple) {\n        // console.log(\"include tuple word, and its an array. joining...: \" + result.types)\n        types.push('tuple(' + result.join(',') + ')' + suffix);\n      } else if (!includeTuple) {\n        // console.log(\"don't include tuple, but its an array. joining...: \" + result)\n        types.push('(' + result.join(',') + ')' + suffix);\n      } else {\n        // console.log(\"its a single type within a tuple: \" + result.types)\n        types.push('(' + result + ')');\n      }\n    } else {\n      // console.log(\"its a type and not directly in a tuple: \" + param.type)\n      types.push(param.type);\n    }\n  });\n  return types;\n};\n\nvar SHA3_NULL_S = '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\n/**\r\n * \r\n * @param {*} value \r\n * @returns {string}\r\n */\n\nvar sha3 = function sha3(value) {\n  if (isBigNumber(value)) {\n    value = value.toString();\n  }\n\n  if (isHexStrict(value) && /^0x/i.test(value.toString())) {\n    value = hexToBytes(value);\n  }\n\n  var returnValue = Hash.keccak256(value); // jshint ignore:line\n\n  if (returnValue === SHA3_NULL_S) {\n    return null;\n  } else {\n    return returnValue;\n  }\n}; // expose the under the hood keccak256\n\n\nsha3._Hash = Hash;\n/**\r\n * Check if the string is hexadecimal, 0x is required in front\r\n * @param {string} hex \r\n * @returns {boolean}\r\n */\n\nvar isHexStrict = function isHexStrict(hex) {\n  return (judge(hex) === 'string' || judge(hex) === 'number') && /^(-)?0x[0-9a-f]*$/i.test(hex);\n};\n/**\r\n * Convert hexadecimal string to byte array\r\n * Note: implemented from crypto-js\r\n * @param {string} hex \r\n * @returns {number[]} byte array\r\n */\n\n\nvar hexToBytes = function hexToBytes(hex) {\n  hex = hex.toString(16);\n\n  if (!isHexStrict(hex)) {\n    throw new Error('Given value \"' + hex + '\" is not a valid hex string.');\n  }\n\n  hex = hex.replace(/^0x/i, '');\n  var bytes = [];\n\n  for (var c = 0; c < hex.length; c += 2) {\n    bytes.push(parseInt(hex.substr(c, 2), 16));\n  }\n\n  return bytes;\n};\n\nvar sign = function sign(msg, privateKey) {\n  return new Promise(function (resolve, reject) {\n    var message = sha256(msg);\n    message = toUint8Array(message);\n    privateKey = toUint8Array(privateKey);\n    var sig = secp256k1.ecdsaSign(message, privateKey);\n    var signature = Buffer.from(sig.signature, \"hex\").toString(\"hex\") + Buffer.from([sig.recid], \"hex\").toString(\"hex\");\n    resolve(signature);\n  });\n};\n\nmodule.exports = {\n  isAccount: isAccount,\n  _fireError: _fireError,\n  _jsonInterfaceMethodToString: _jsonInterfaceMethodToString,\n  toBigNumber: toBigNumber,\n  isBigNumber: isBigNumber,\n  encode: encode,\n  decode: decode,\n  encodeAccount: encodeAccount,\n  fromCan: fromCan,\n  fromCanToken: fromCanToken,\n  toCan: toCan,\n  toCanToken: toCanToken,\n  judge: judge,\n  sha3: sha3,\n  sign: sign\n};","map":null,"metadata":{},"sourceType":"script"}