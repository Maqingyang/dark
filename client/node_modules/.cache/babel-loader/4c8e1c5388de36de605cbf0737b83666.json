{"ast":null,"code":"/**\n *  Conversion Utilities\n *\n */\nvar defineProperty = require('./properties.js').defineProperty;\n\nvar errors = require('./errors');\n/**\n * \n * @param {*} value \n * @returns \n */\n\n\nfunction isBigNumber(value) {\n  return value instanceof types_1.BigNumber;\n}\n\nfunction isHexable(value) {\n  return !!value.toHexString;\n}\n\nfunction addSlice(array) {\n  if (array.slice) {\n    return array;\n  }\n\n  array.slice = function () {\n    var args = Array.prototype.slice.call(arguments);\n    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n  };\n\n  return array;\n}\n/**\n * \n * @param {*} array \n * @returns \n */\n\n\nfunction addSlice(array) {\n  if (array.slice) {\n    return array;\n  }\n\n  array.slice = function () {\n    var args = Array.prototype.slice.call(arguments);\n    return new Uint8Array(Array.prototype.slice.apply(array, args));\n  };\n\n  return array;\n}\n/**\n * \n * @param {*} value \n * @returns \n */\n\n\nfunction isArrayish(value) {\n  if (!value || parseInt(String(value.length)) != value.length || typeof value === 'string') {\n    return false;\n  }\n\n  for (var i = 0; i < value.length; i++) {\n    var v = value[i];\n\n    if (v < 0 || v >= 256 || parseInt(String(v)) != v) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.isArrayish = isArrayish;\n\nfunction isInteger(value) {\n  return typeof value === \"number\" && value == value && value % 1 === 0;\n}\n\nfunction isBytes(value) {\n  if (value == null) {\n    return false;\n  }\n\n  if (value.constructor === Uint8Array) {\n    return true;\n  }\n\n  if (typeof value === \"string\") {\n    return false;\n  }\n\n  if (!isInteger(value.length) || value.length < 0) {\n    return false;\n  }\n\n  for (var i = 0; i < value.length; i++) {\n    var v = value[i];\n\n    if (!isInteger(v) || v < 0 || v >= 256) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * \n * @param {*} value \n * @returns {boolean}\n */\n\n\nfunction isArrayish(value) {\n  if (!value || parseInt(value.length) != value.length || typeof value === 'string') {\n    return false;\n  }\n\n  for (var i = 0; i < value.length; i++) {\n    var v = value[i];\n\n    if (v < 0 || v >= 256 || parseInt(v) != v) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * \n * @param {*} value \n * @returns {array}\n */\n\n\nfunction arrayify(value, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (typeof value === \"number\") {\n    // logger.checkSafeUint53(value, \"invalid arrayify value\");\n    var result = [];\n\n    while (value) {\n      result.unshift(value & 0xff);\n      value = parseInt(String(value / 256));\n    }\n\n    if (result.length === 0) {\n      result.push(0);\n    }\n\n    return addSlice(new Uint8Array(result));\n  }\n\n  if (options.allowMissingPrefix && typeof value === \"string\" && value.substring(0, 2) !== \"0x\") {\n    value = \"0x\" + value;\n  }\n\n  if (isHexable(value)) {\n    value = value.toHexString();\n  }\n\n  if (isHexString(value)) {\n    var hex = value.substring(2);\n\n    if (hex.length % 2) {\n      if (options.hexPad === \"left\") {\n        hex = \"0x0\" + hex.substring(2);\n      } else if (options.hexPad === \"right\") {\n        hex += \"0\";\n      } else {\n        errors.throwError(\"hex data is odd-length\", \"value\", value);\n      }\n    }\n\n    var _result = [];\n\n    for (var i = 0; i < hex.length; i += 2) {\n      _result.push(parseInt(hex.substring(i, i + 2), 16));\n    }\n\n    return addSlice(new Uint8Array(_result));\n  }\n\n  if (isBytes(value)) {\n    return addSlice(new Uint8Array(value));\n  }\n\n  return errors.throwError(\"invalid arrayify value\", \"value\", value);\n}\n/**\n * \n * @param {array} objects \n * @returns {array}\n */\n\n\nfunction concat(objects) {\n  var arrays = [];\n  var length = 0;\n\n  for (var i = 0; i < objects.length; i++) {\n    var object = arrayify(objects[i]);\n    arrays.push(object);\n    length += object.length;\n  }\n\n  var result = new Uint8Array(length);\n  var offset = 0;\n\n  for (var _i = 0; _i < arrays.length; _i++) {\n    result.set(arrays[_i], offset);\n    offset += arrays[_i].length;\n  }\n\n  return addSlice(result);\n}\n/**\n * \n * @param {*} value \n * @returns \n */\n\n\nfunction stripZeros(value) {\n  value = arrayify(value);\n\n  if (value.length === 0) {\n    return value;\n  } // Find the first non-zero entry\n\n\n  var start = 0;\n\n  while (value[start] === 0) {\n    start++;\n  } // If we started with zeros, strip them\n\n\n  if (start) {\n    value = value.slice(start);\n  }\n\n  return value;\n}\n/**\n * \n * @param {*} value \n * @param {*} length \n * @returns {array}\n */\n\n\nfunction padZeros(value, length) {\n  value = arrayify(value);\n\n  if (length < value.length) {\n    throw new Error('cannot pad');\n  }\n\n  var result = new Uint8Array(length);\n  result.set(value, length - value.length);\n  return addSlice(result);\n}\n/**\n * \n * @param {*} value \n * @param {*} length \n * @returns {boolean}\n */\n\n\nfunction isHexString(value, length) {\n  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n    return false;\n  }\n\n  if (length && value.length !== 2 + 2 * length) {\n    return false;\n  }\n\n  return true;\n}\n\nvar HexCharacters = '0123456789abcdef';\n/**\n * \n * @param {*} value \n * @returns \n */\n\nfunction hexlify(value) {\n  if (value && value.toHexString) {\n    return value.toHexString();\n  }\n\n  if (typeof value === 'number') {\n    if (value < 0) {\n      errors.throwError('cannot hexlify negative value', errors.INVALID_ARG, {\n        arg: 'value',\n        value: value\n      });\n    }\n\n    var hex = '';\n\n    while (value) {\n      hex = HexCharacters[value & 0x0f] + hex;\n      value = parseInt(value / 16);\n    }\n\n    if (hex.length) {\n      if (hex.length % 2) {\n        hex = '0' + hex;\n      }\n\n      return '0x' + hex;\n    }\n\n    return '0x00';\n  }\n\n  if (isHexString(value)) {\n    if (value.length % 2) {\n      value = '0x0' + value.substring(2);\n    }\n\n    return value;\n  }\n\n  if (isArrayish(value)) {\n    var result = [];\n\n    for (var i = 0; i < value.length; i++) {\n      var v = value[i];\n      result.push(HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f]);\n    }\n\n    return '0x' + result.join('');\n  }\n\n  errors.throwError('invalid hexlify value', {\n    arg: 'value',\n    value: value\n  });\n}\n/**\n * \n * @param {*} value \n * @returns \n */\n\n\nfunction hexStripZeros(value) {\n  while (value.length > 3 && value.substring(0, 3) === '0x0') {\n    value = '0x' + value.substring(3);\n  }\n\n  return value;\n}\n/**\n * \n * @param {*} value \n * @param {*} length \n * @returns \n */\n\n\nfunction hexZeroPad(value, length) {\n  while (value.length < 2 * length + 2) {\n    value = '0x0' + value.substring(2);\n  }\n\n  return value;\n}\n/* @TODO: Add something like this to make slicing code easier to understand\nfunction hexSlice(hex, start, end) {\n    hex = hexlify(hex);\n    return '0x' + hex.substring(2 + start * 2, 2 + end * 2);\n}\n*/\n\n/**\n * \n * @param {*} signature \n * @returns \n */\n\n\nfunction splitSignature(signature) {\n  signature = arrayify(signature);\n\n  if (signature.length !== 65) {\n    throw new Error('invalid signature');\n  }\n\n  var v = signature[64];\n\n  if (v !== 27 && v !== 28) {\n    v = 27 + v % 2;\n  }\n\n  return {\n    r: hexlify(signature.slice(0, 32)),\n    s: hexlify(signature.slice(32, 64)),\n    v: v\n  };\n}\n\nmodule.exports = {\n  arrayify: arrayify,\n  isArrayish: isArrayish,\n  concat: concat,\n  padZeros: padZeros,\n  stripZeros: stripZeros,\n  splitSignature: splitSignature,\n  hexlify: hexlify,\n  isHexString: isHexString,\n  hexStripZeros: hexStripZeros,\n  hexZeroPad: hexZeroPad\n};","map":null,"metadata":{},"sourceType":"script"}