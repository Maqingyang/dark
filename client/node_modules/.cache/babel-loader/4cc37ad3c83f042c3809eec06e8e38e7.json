{"ast":null,"code":"'use strict'; // See: \n\n/*\r\n *   [\r\n *       { \r\n *           \"constant\": true, \r\n *           \"inputs\": [\r\n *               { \"name\": \"user\", \"type\": \"address\" }\r\n *           ], \r\n *           \"name\": \"accountLevel\", \r\n *           \"outputs\": [\r\n *               { \"name\": \"\", \"type\": \"uint256\" }\r\n *           ], \r\n *           \"payable\": false, \r\n *           \"type\": \"function\", \r\n *           \"stateMutability\": \"view\"\r\n *       }\r\n *   ]\r\n */\n\nvar utils = function () {\n  var convert = require('./convert.js');\n\n  var utf8 = require('./utf8.js');\n\n  return {\n    defineProperty: require('./properties.js').defineProperty,\n    arrayify: convert.arrayify,\n    padZeros: convert.padZeros,\n    bigNumberify: require('./bignumber.js').bigNumberify,\n    getAddress: require('./address').getAddress,\n    concat: convert.concat,\n    isHexString: convert.isHexString,\n    toUtf8Bytes: utf8.toUtf8Bytes,\n    toUtf8String: utf8.toUtf8String,\n    hexlify: convert.hexlify\n  };\n}();\n\nvar errors = require('./errors');\n\nvar bs58check = require(\"bs58check\");\n\nvar paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nvar paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n/**\r\n * \r\n * @param {*} type \r\n * @param {*} value \r\n * @returns \r\n */\n\nfunction defaultCoerceFunc(type, value) {\n  var match = type.match(paramTypeNumber);\n\n  if (match && parseInt(match[2]) <= 48) {\n    return value.toNumber();\n  }\n\n  return value;\n}\n/**\r\n * Shallow copy object (will move to utils/properties in v4)\r\n * @param {*} object \r\n * @returns \r\n */\n\n\nfunction shallowCopy(object) {\n  var result = {};\n\n  for (var key in object) {\n    result[key] = object[key];\n  }\n\n  return result;\n} // Parsing for Solidity Signatures\n\n\nvar regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nvar regexIdentifier = new RegExp(\"^[A-Za-z_][A-Za-z0-9_]*$\"); // var close = { \"(\": \")\", \"[\": \"]\" };\n\n/**\r\n * \r\n * @param {string} type \r\n * @returns {string}\r\n */\n\nfunction verifyType(type) {\n  // These need to be transformed to their full description\n  if (type.match(/^uint($|[^1-9])/)) {\n    type = 'uint256' + type.substring(4);\n  } else if (type.match(/^int($|[^1-9])/)) {\n    type = 'int256' + type.substring(3);\n  }\n\n  return type;\n}\n/**\r\n * \r\n * @param {*} param \r\n * @param {*} allowIndexed \r\n * @returns {{type: string; name: string; state: {allowType: boolean;};}}\r\n */\n\n\nfunction parseParam(param, allowIndexed) {\n  function throwError(i) {\n    throw new Error('unexpected character \"' + param[i] + '\" at position ' + i + ' in \"' + param + '\"');\n  }\n\n  var parent = {\n    type: '',\n    name: '',\n    state: {\n      allowType: true\n    }\n  };\n  var node = parent;\n\n  for (var i = 0; i < param.length; i++) {\n    var c = param[i];\n\n    switch (c) {\n      case '(':\n        if (!node.state.allowParams) {\n          throwError(i);\n        }\n\n        delete node.state.allowType;\n        node.type = verifyType(node.type);\n        node.components = [{\n          type: '',\n          name: '',\n          parent: node,\n          state: {\n            allowType: true\n          }\n        }];\n        node = node.components[0];\n        break;\n\n      case ')':\n        delete node.state;\n        node.type = verifyType(node.type);\n        var child = node;\n        node = node.parent;\n\n        if (!node) {\n          throwError(i);\n        }\n\n        delete child.parent;\n        delete node.state.allowParams;\n        node.state.allowName = true;\n        node.state.allowArray = true;\n        break;\n\n      case ',':\n        delete node.state;\n        node.type = verifyType(node.type);\n        var sibling = {\n          type: '',\n          name: '',\n          parent: node.parent,\n          state: {\n            allowType: true\n          }\n        };\n        node.parent.components.push(sibling);\n        delete node.parent;\n        node = sibling;\n        break;\n      // Hit a space...\n\n      case ' ':\n        // If reading type, the type is done and may read a param or name\n        if (node.state.allowType) {\n          if (node.type !== '') {\n            node.type = verifyType(node.type);\n            delete node.state.allowType;\n            node.state.allowName = true;\n            node.state.allowParams = true;\n          }\n        } // If reading name, the name is done\n\n\n        if (node.state.allowName) {\n          if (node.name !== '') {\n            if (allowIndexed && node.name === 'indexed') {\n              node.indexed = true;\n              node.name = '';\n            } else {\n              delete node.state.allowName;\n            }\n          }\n        }\n\n        break;\n\n      case '[':\n        if (!node.state.allowArray) {\n          throwError(i);\n        } //if (!node.array) { node.array = ''; }\n        //node.array += c;\n\n\n        node.type += c;\n        delete node.state.allowArray;\n        delete node.state.allowName;\n        node.state.readArray = true;\n        break;\n\n      case ']':\n        if (!node.state.readArray) {\n          throwError(i);\n        } //node.array += c;\n\n\n        node.type += c;\n        delete node.state.readArray;\n        node.state.allowArray = true;\n        node.state.allowName = true;\n        break;\n\n      default:\n        if (node.state.allowType) {\n          node.type += c;\n          node.state.allowParams = true;\n          node.state.allowArray = true;\n        } else if (node.state.allowName) {\n          node.name += c;\n          delete node.state.allowArray;\n        } else if (node.state.readArray) {\n          //node.array += c;\n          node.type += c;\n        } else {\n          throwError(i);\n        }\n\n    }\n  }\n\n  if (node.parent) {\n    throw new Error(\"unexpected eof\");\n  }\n\n  delete parent.state;\n  parent.type = verifyType(parent.type); //verifyType(parent);\n\n  return parent;\n}\n/**\r\n * \r\n * @param {*} fragment \r\n * @returns {{anonymous: boolean;inputs: any[];type: string;}}\r\n */\n\n\nfunction parseSignatureEvent(fragment) {\n  var abi = {\n    anonymous: false,\n    inputs: [],\n    type: 'event'\n  };\n  var match = fragment.match(regexParen);\n\n  if (!match) {\n    throw new Error('invalid event: ' + fragment);\n  }\n\n  abi.name = match[1].trim();\n  splitNesting(match[2]).forEach(function (param) {\n    param = parseParam(param, true);\n    param.indexed = !!param.indexed;\n    abi.inputs.push(param);\n  });\n  match[3].split(' ').forEach(function (modifier) {\n    switch (modifier) {\n      case 'anonymous':\n        abi.anonymous = true;\n        break;\n\n      case '':\n        break;\n\n      default:\n        console.log('unknown modifier: ' + modifier);\n    }\n  });\n\n  if (abi.name && !abi.name.match(regexIdentifier)) {\n    throw new Error('invalid identifier: \"' + abi.name + '\"');\n  }\n\n  return abi;\n}\n/**\r\n * \r\n * @param {*} fragment \r\n * @returns {{constant: boolean;inputs: any[];outputs: any[];payable: boolean;type: string;}}\r\n */\n\n\nfunction parseSignatureFunction(fragment) {\n  var abi = {\n    constant: false,\n    inputs: [],\n    outputs: [],\n    payable: false,\n    type: 'function'\n  };\n  var comps = fragment.split(' returns ');\n  var left = comps[0].match(regexParen);\n\n  if (!left) {\n    throw new Error('invalid signature');\n  }\n\n  abi.name = left[1].trim();\n\n  if (!abi.name.match(regexIdentifier)) {\n    throw new Error('invalid identifier: \"' + left[1] + '\"');\n  }\n\n  splitNesting(left[2]).forEach(function (param) {\n    abi.inputs.push(parseParam(param));\n  });\n  left[3].split(' ').forEach(function (modifier) {\n    switch (modifier) {\n      case 'constant':\n        abi.constant = true;\n        break;\n\n      case 'payable':\n        abi.payable = true;\n        break;\n\n      case 'pure':\n        abi.constant = true;\n        abi.stateMutability = 'pure';\n        break;\n\n      case 'view':\n        abi.constant = true;\n        abi.stateMutability = 'view';\n        break;\n\n      case '':\n        break;\n\n      default:\n        console.log('unknown modifier: ' + modifier);\n    }\n  }); // We have outputs\n\n  if (comps.length > 1) {\n    var right = comps[1].match(regexParen);\n\n    if (right[1].trim() != '' || right[3].trim() != '') {\n      throw new Error('unexpected tokens');\n    }\n\n    splitNesting(right[2]).forEach(function (param) {\n      abi.outputs.push(parseParam(param));\n    });\n  }\n\n  return abi;\n}\n/**\r\n * \r\n * @param {string} fragment \r\n * @returns {{anonymous: boolean;inputs: any[];type: string;} | {constant: boolean;inputs: any[];outputs: any[];payable: boolean;type: string;}}\r\n */\n\n\nfunction parseSignature(fragment) {\n  if (typeof fragment === 'string') {\n    // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n    fragment = fragment.replace(/\\(/g, ' (').replace(/\\)/g, ') ').replace(/\\s+/g, ' ');\n    fragment = fragment.trim();\n\n    if (fragment.substring(0, 6) === 'event ') {\n      return parseSignatureEvent(fragment.substring(6).trim());\n    } else {\n      if (fragment.substring(0, 9) === 'function ') {\n        fragment = fragment.substring(9);\n      }\n\n      return parseSignatureFunction(fragment.trim());\n    }\n  }\n\n  throw new Error('unknown fragment');\n} // Coders start\n\n/**\r\n * \r\n * @param {Function} coerceFunc \r\n * @returns \r\n */\n\n\nfunction coderNull(coerceFunc) {\n  return {\n    name: 'null',\n    type: '',\n\n    /**\r\n     * \r\n     * @param {*} value \r\n     * @returns \r\n     */\n    encode: function encode(value) {\n      return utils.arrayify([]);\n    },\n\n    /**\r\n     * \r\n     * @param {*} data \r\n     * @param {*} offset \r\n     * @returns \r\n     */\n    decode: function decode(data, offset) {\n      if (offset > data.length) {\n        throw new Error('invalid null');\n      }\n\n      return {\n        consumed: 0,\n        value: coerceFunc('null', undefined)\n      };\n    },\n    dynamic: false\n  };\n}\n/**\r\n * \r\n * @param {Function} coerceFunc \r\n * @param {number} size \r\n * @param {*} signed \r\n * @param {string} localName \r\n * @returns \r\n */\n\n\nvar coderNumber = function coderNumber(coerceFunc, size, signed, localName) {\n  var name = (signed ? 'int' : 'uint') + size * 8;\n  return {\n    localName: localName,\n    name: name,\n    type: name,\n\n    /**\r\n     * \r\n     * @param {*} value \r\n     * @returns \r\n     */\n    encode: function encode(value) {\n      try {\n        value = utils.bigNumberify(value);\n      } catch (error) {\n        errors.throwError('invalid number value', errors.INVALID_ARGUMENT, {\n          arg: localName,\n          type: typeof value,\n          value: value\n        });\n      }\n\n      value = value.toTwos(size * 8).maskn(size * 8);\n\n      if (signed) {\n        value = value.fromTwos(size * 8).toTwos(256);\n      }\n\n      return utils.padZeros(utils.arrayify(value), 32);\n    },\n\n    /**\r\n     * \r\n     * @param {*} data \r\n     * @param {*} offset \r\n     * @returns \r\n     */\n    decode: function decode(data, offset) {\n      if (data.length < offset + 32) {\n        errors.throwError('insufficient data for ' + name + ' type', errors.INVALID_ARGUMENT, {\n          arg: localName,\n          coderType: name,\n          value: utils.hexlify(data.slice(offset, offset + 32))\n        });\n      }\n\n      var junkLength = 32 - size;\n      var value = utils.bigNumberify(data.slice(offset + junkLength, offset + 32));\n\n      if (signed) {\n        value = value.fromTwos(size * 8);\n      } else {\n        value = value.maskn(size * 8);\n      } //if (size <= 6) { value = value.toNumber(); }\n\n\n      return {\n        consumed: 32,\n        value: coerceFunc(name, value)\n      };\n    }\n  };\n};\n\nvar uint256Coder = coderNumber(function (type, value) {\n  return value;\n}, 32, false);\n/**\r\n * \r\n * @param {Function} coerceFunc \r\n * @param {string} localName \r\n * @returns \r\n */\n\nfunction coderBoolean(coerceFunc, localName) {\n  return {\n    localName: localName,\n    name: 'bool',\n    type: 'bool',\n\n    /**\r\n     * \r\n     * @param {*} value \r\n     * @returns \r\n     */\n    encode: function encode(value) {\n      // eslint-disable-next-line no-extra-boolean-cast\n      return uint256Coder.encode(!!value ? 1 : 0);\n    },\n\n    /**\r\n     * \r\n     * @param {*} data \r\n     * @param {*} offset \r\n     * @returns \r\n     */\n    decode: function decode(data, offset) {\n      try {\n        var result = uint256Coder.decode(data, offset);\n      } catch (error) {\n        if (error.reason === 'insufficient data for uint256 type') {\n          errors.throwError('insufficient data for boolean type', errors.INVALID_ARGUMENT, {\n            arg: localName,\n            coderType: 'boolean',\n            value: error.value\n          });\n        }\n\n        throw error;\n      }\n\n      return {\n        consumed: result.consumed,\n        value: coerceFunc('boolean', !result.value.isZero())\n      };\n    }\n  };\n}\n/**\r\n * \r\n * @param {Function} coerceFunc \r\n * @param {number} length \r\n * @param {string} localName \r\n * @returns \r\n */\n\n\nfunction coderFixedBytes(coerceFunc, length, localName) {\n  var name = 'bytes' + length;\n  return {\n    localName: localName,\n    name: name,\n    type: name,\n\n    /**\r\n     * \r\n     * @param {*} value \r\n     * @returns \r\n     */\n    encode: function encode(value) {\n      if (utils.isHexString(value) && value.length % 2 !== 0) {\n        throw new Error('hex string cannot be odd-length');\n      }\n\n      try {\n        value = utils.arrayify(value); // @TODO: In next major change, the value.length MUST equal the\n        // length, but that is a backward-incompatible change, so here\n        // we just check for things that can cause problems.\n\n        if (value.length > 32) {\n          throw new Error('too many bytes for field');\n        }\n      } catch (error) {\n        errors.throwError('invalid ' + name + ' value', errors.INVALID_ARGUMENT, {\n          arg: localName,\n          type: typeof value,\n          value: error.value\n        });\n      }\n\n      if (value.length === 32) {\n        return value;\n      }\n\n      var result = new Uint8Array(32);\n      result.set(value);\n      return result;\n    },\n\n    /**\r\n     * \r\n     * @param {*} data \r\n     * @param {*} offset \r\n     * @returns \r\n     */\n    decode: function decode(data, offset) {\n      if (data.length < offset + 32) {\n        errors.throwError('insufficient data for ' + name + ' type', errors.INVALID_ARGUMENT, {\n          arg: localName,\n          coderType: name,\n          value: utils.hexlify(data.slice(offset, offset + 32))\n        });\n      }\n\n      return {\n        consumed: 32,\n        value: coerceFunc(name, utils.hexlify(data.slice(offset, offset + length)))\n      };\n    }\n  };\n}\n/**\r\n * \r\n * @param {Function} coerceFunc \r\n * @param {string} localName \r\n * @returns \r\n */\n\n\nfunction coderAddress(coerceFunc, localName) {\n  return {\n    localName: localName,\n    name: 'address',\n    type: 'address',\n\n    /**\r\n     * \r\n     * @param {*} value \r\n     * @returns \r\n     */\n    encode: function encode(value) {\n      try {\n        value = utils.arrayify(utils.getAddress(value));\n      } catch (error) {\n        errors.throwError('invalid address', errors.INVALID_ARGUMENT, {\n          arg: localName,\n          type: typeof value,\n          value: value\n        });\n      }\n\n      var result = new Uint8Array(32);\n      result.set(value, 12);\n      return result;\n    },\n\n    /**\r\n     * \r\n     * @param {*} data \r\n     * @param {*} offset \r\n     * @returns \r\n     */\n    decode: function decode(data, offset) {\n      if (data.length < offset + 32) {\n        errors.throwError('insufficuent data for address type', errors.INVALID_ARGUMENT, {\n          arg: localName,\n          coderType: 'address',\n          value: utils.hexlify(data.slice(offset, offset + 32))\n        });\n      }\n\n      return {\n        consumed: 32,\n        value: coerceFunc('address', utils.getAddress(utils.hexlify(data.slice(offset, offset + 32))))\n      };\n    }\n  };\n}\n/**\r\n * \r\n * @param {*} value \r\n * @returns \r\n */\n\n\nfunction _encodeDynamicBytes(value) {\n  var dataLength = parseInt(32 * Math.ceil(value.length / 32));\n  var padding = new Uint8Array(dataLength - value.length);\n  return utils.concat([uint256Coder.encode(value.length), value, padding]);\n}\n/**\r\n * \r\n * @param {array} data \r\n * @param {number} offset \r\n * @param {string} localName \r\n * @returns \r\n */\n\n\nfunction _decodeDynamicBytes(data, offset, localName) {\n  if (data.length < offset + 32) {\n    errors.throwError('insufficient data for dynamicBytes length', errors.INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: utils.hexlify(data.slice(offset, offset + 32))\n    });\n  }\n\n  var length = uint256Coder.decode(data, offset).value;\n\n  try {\n    length = length.toNumber();\n  } catch (error) {\n    errors.throwError('dynamic bytes count too large', errors.INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: length.toString()\n    });\n  }\n\n  if (data.length < offset + 32 + length) {\n    errors.throwError('insufficient data for dynamicBytes type', errors.INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: utils.hexlify(data.slice(offset, offset + 32 + length))\n    });\n  }\n\n  return {\n    consumed: parseInt(32 + 32 * Math.ceil(length / 32)),\n    value: data.slice(offset + 32, offset + 32 + length)\n  };\n}\n/**\r\n * \r\n * @param {Function} coerceFunc \r\n * @param {string} localName \r\n * @returns \r\n */\n\n\nfunction coderDynamicBytes(coerceFunc, localName) {\n  return {\n    localName: localName,\n    name: 'bytes',\n    type: 'bytes',\n\n    /**\r\n     * \r\n     * @param {*} value \r\n     * @returns \r\n     */\n    encode: function encode(value) {\n      try {\n        value = utils.arrayify(value);\n      } catch (error) {\n        errors.throwError('invalid bytes value', errors.INVALID_ARGUMENT, {\n          arg: localName,\n          type: typeof value,\n          value: error.value\n        });\n      }\n\n      return _encodeDynamicBytes(value);\n    },\n\n    /**\r\n     * \r\n     * @param {*} data \r\n     * @param {*} offset \r\n     * @returns \r\n     */\n    decode: function decode(data, offset) {\n      var result = _decodeDynamicBytes(data, offset, localName);\n\n      result.value = coerceFunc('bytes', utils.hexlify(result.value));\n      return result;\n    },\n    dynamic: true\n  };\n}\n/**\r\n * \r\n * @param {Function} coerceFunc \r\n * @param {string} localName \r\n * @returns \r\n */\n\n\nfunction coderString(coerceFunc, localName) {\n  return {\n    localName: localName,\n    name: 'string',\n    type: 'string',\n\n    /**\r\n     * \r\n     * @param {*} value \r\n     * @returns \r\n     */\n    encode: function encode(value) {\n      if (typeof value !== 'string') {\n        errors.throwError('invalid string value', errors.INVALID_ARGUMENT, {\n          arg: localName,\n          type: typeof value,\n          value: value\n        });\n      }\n\n      return _encodeDynamicBytes(utils.toUtf8Bytes(value));\n    },\n\n    /**\r\n     * \r\n     * @param {*} data \r\n     * @param {*} offset \r\n     * @returns \r\n     */\n    decode: function decode(data, offset) {\n      var result = _decodeDynamicBytes(data, offset, localName);\n\n      result.value = coerceFunc('string', utils.toUtf8String(result.value));\n      return result;\n    },\n    dynamic: true\n  };\n}\n/**\r\n * \r\n * @param {number} size \r\n * @returns {number}\r\n */\n\n\nfunction alignSize(size) {\n  return parseInt(32 * Math.ceil(size / 32));\n}\n/**\r\n * \r\n * @param {array} coders \r\n * @param {*} values \r\n * @returns \r\n */\n\n\nfunction pack(coders, values) {\n  if (Array.isArray(values)) {// do nothing\n  } else if (values && typeof values === 'object') {\n    var arrayValues = [];\n    coders.forEach(function (coder) {\n      arrayValues.push(values[coder.localName]);\n    });\n    values = arrayValues;\n  } else {\n    errors.throwError('invalid tuple value', errors.INVALID_ARGUMENT, {\n      coderType: 'tuple',\n      type: typeof values,\n      value: values\n    });\n  }\n\n  if (coders.length !== values.length) {\n    errors.throwError('types/value length mismatch', errors.INVALID_ARGUMENT, {\n      coderType: 'tuple',\n      value: values\n    });\n  }\n\n  values = Array.isArray(values[0]) ? values[0] : values;\n  var parts = [];\n  coders.forEach(function (coder, index) {\n    // if (values[index].toString().indexOf(\"mcp\") === 0) {\n    //     console.log(values[index])\n    //     const bytecode = bs58check.decode(values[index].substr(3)).slice(1);\n    //     parts.push({ dynamic: coder.dynamic, value: bytecode });\n    // } else {\n    //     parts.push({ dynamic: coder.dynamic, value: coder.encode(values[index]) });\n    // }\n    parts.push({\n      dynamic: coder.dynamic,\n      value: coder.encode(values[index])\n    });\n  });\n  var staticSize = 0,\n      dynamicSize = 0;\n  parts.forEach(function (part, index) {\n    if (part.dynamic) {\n      staticSize += 32;\n      dynamicSize += alignSize(part.value.length);\n    } else {\n      staticSize += alignSize(part.value.length);\n    }\n  });\n  var offset = 0,\n      dynamicOffset = staticSize;\n  var data = new Uint8Array(staticSize + dynamicSize);\n  parts.forEach(function (part, index) {\n    if (part.dynamic) {\n      //uint256Coder.encode(dynamicOffset).copy(data, offset);\n      data.set(uint256Coder.encode(dynamicOffset), offset);\n      offset += 32; //part.value.copy(data, dynamicOffset);  @TODO\n\n      data.set(part.value, dynamicOffset);\n      dynamicOffset += alignSize(part.value.length);\n    } else {\n      //part.value.copy(data, offset);  @TODO\n      data.set(part.value, offset);\n      offset += alignSize(part.value.length);\n    }\n  });\n  return data;\n}\n/**\r\n * \r\n * @param {array} coders \r\n * @param {*} data \r\n * @param {number} offset \r\n * @returns {{value: any[];consumed: number;}}\r\n */\n\n\nfunction unpack(coders, data, offset) {\n  var baseOffset = offset;\n  var consumed = 0;\n  var value = [];\n  coders.forEach(function (coder) {\n    var result;\n\n    if (coder.dynamic) {\n      var dynamicOffset = uint256Coder.decode(data, offset);\n      result = coder.decode(data, baseOffset + dynamicOffset.value.toNumber()); // The dynamic part is leap-frogged somewhere else; doesn't count towards size\n\n      result.consumed = dynamicOffset.consumed;\n    } else {\n      //console.log(data, offset)\n      //console.log(coder.decode.toString())\n      result = coder.decode(data, offset); //console.log(6,result)\n    }\n\n    if (result.value != undefined) {\n      value.push(result.value); //console.log(value)\n    }\n\n    offset += result.consumed;\n    consumed += result.consumed; //console.log(consumed)\n  });\n  coders.forEach(function (coder, index) {\n    var name = coder.localName;\n\n    if (!name) {\n      return;\n    }\n\n    if (typeof name === 'object') {\n      name = name.name;\n    }\n\n    if (!name) {\n      return;\n    }\n\n    if (name === 'length') {\n      name = '_length';\n    }\n\n    if (value[name] != null) {\n      return;\n    }\n\n    value[name] = value[index];\n  }); //console.log(value,consumed)\n\n  return {\n    value: value,\n    consumed: consumed\n  }; // return result;\n}\n/**\r\n * \r\n * @param {Function} coerceFunc \r\n * @param {*} coder \r\n * @param {number} length \r\n * @param {string} localName \r\n * @returns \r\n */\n\n\nfunction coderArray(coerceFunc, coder, length, localName) {\n  var type = coder.type + '[' + (length >= 0 ? length : '') + ']';\n  return {\n    coder: coder,\n    localName: localName,\n    length: length,\n    name: 'array',\n    type: type,\n\n    /**\r\n     * \r\n     * @param {*} value \r\n     * @returns \r\n     */\n    encode: function encode(value) {\n      if (!Array.isArray(value)) {\n        errors.throwError('expected array value', errors.INVALID_ARGUMENT, {\n          arg: localName,\n          coderType: 'array',\n          type: typeof value,\n          value: value\n        });\n      }\n\n      var count = length;\n      var result = new Uint8Array(0);\n\n      if (count === -1) {\n        count = value.length;\n        result = uint256Coder.encode(count);\n      }\n\n      if (count !== value.length) {\n        errors.throwError('array value length mismatch', errors.INVALID_ARGUMENT, {\n          arg: localName,\n          coderType: 'array',\n          count: value.length,\n          expectedCount: count,\n          value: value\n        });\n      }\n\n      var coders = [];\n      value.forEach(function (value) {\n        coders.push(coder);\n      });\n      return utils.concat([result, pack(coders, value)]);\n    },\n\n    /**\r\n     * \r\n     * @param {*} data \r\n     * @param {*} offset \r\n     * @returns \r\n     */\n    decode: function decode(data, offset) {\n      // @TODO:\n      //if (data.length < offset + length * 32) { throw new Error('invalid array'); }\n      var consumed = 0;\n      var count = length;\n\n      if (count === -1) {\n        try {\n          var decodedLength = uint256Coder.decode(data, offset);\n        } catch (error) {\n          errors.throwError('insufficient data for dynamic array length', errors.INVALID_ARGUMENT, {\n            arg: localName,\n            coderType: 'array',\n            value: error.value\n          });\n        }\n\n        try {\n          count = decodedLength.value.toNumber();\n        } catch (error) {\n          errors.throwError('array count too large', errors.INVALID_ARGUMENT, {\n            arg: localName,\n            coderType: 'array',\n            value: decodedLength.value.toString()\n          });\n        }\n\n        consumed += decodedLength.consumed;\n        offset += decodedLength.consumed;\n      } // We don't want the children to have a localName\n\n\n      var subCoder = {\n        name: coder.name,\n        type: coder.type,\n        encode: coder.encode,\n        decode: coder.decode,\n        dynamic: coder.dynamic\n      };\n      var coders = [];\n\n      for (var i = 0; i < count; i++) {\n        coders.push(subCoder);\n      }\n\n      var result = unpack(coders, data, offset);\n      result.consumed += consumed;\n      result.value = coerceFunc(type, result.value);\n      return result;\n    },\n    dynamic: length === -1 || coder.dynamic\n  };\n}\n/**\r\n * \r\n * @param {Function} coerceFunc \r\n * @param {Array} coders \r\n * @param {string} localName \r\n * @returns \r\n */\n\n\nfunction coderTuple(coerceFunc, coders, localName) {\n  var dynamic = false;\n  var types = [];\n  coders.forEach(function (coder) {\n    //console.log(8,coder)\n    if (coder.dynamic) {\n      dynamic = true;\n    }\n\n    types.push(coder.type);\n  });\n  var type = 'tuple(' + types.join(',') + ')'; //console.log(9,type)\n\n  return {\n    coders: coders,\n    localName: localName,\n    name: 'tuple',\n    type: type,\n    encode: function encode(value) {\n      return pack(coders, value);\n    },\n    decode: function decode(data, offset) {\n      //console.log(5,data,offset,coders)\n      var result = unpack(coders, data, offset); //console.log(3,result)\n\n      result.value = coerceFunc(type, result.value); //console.log(4,result)\n\n      return result;\n    },\n    dynamic: dynamic\n  };\n}\n/*\r\nfunction getTypes(coders) {\r\n    var type = coderTuple(coders).type;\r\n    return type.substring(6, type.length - 1);\r\n}\r\n*/\n\n/**\r\n * \r\n * @param {*} value \r\n * @returns {string[]}\r\n */\n\n\nfunction splitNesting(value) {\n  var result = [];\n  var accum = '';\n  var depth = 0;\n\n  for (var offset = 0; offset < value.length; offset++) {\n    var c = value[offset];\n\n    if (c === ',' && depth === 0) {\n      result.push(accum);\n      accum = '';\n    } else {\n      accum += c;\n\n      if (c === '(') {\n        depth++;\n      } else if (c === ')') {\n        depth--;\n\n        if (depth === -1) {\n          throw new Error('unbalanced parenthsis');\n        }\n      }\n    }\n  }\n\n  result.push(accum);\n  return result;\n}\n\nvar paramTypeSimple = {\n  address: coderAddress,\n  bool: coderBoolean,\n  string: coderString,\n  bytes: coderDynamicBytes\n};\n/**\r\n * \r\n * @param {Function} coerceFunc \r\n * @param {array} components \r\n * @param {string} localName \r\n * @returns \r\n */\n\nfunction getTupleParamCoder(coerceFunc, components, localName) {\n  if (!components) {\n    components = [];\n  }\n\n  var coders = [];\n  components.forEach(function (component) {\n    coders.push(getParamCoder(coerceFunc, component));\n  });\n  return coderTuple(coerceFunc, coders, localName);\n}\n/**\r\n * \r\n * @param {Function} coerceFunc \r\n * @param {*} param \r\n * @returns \r\n */\n\n\nfunction getParamCoder(coerceFunc, param) {\n  // console.log(param)\n  var coder = paramTypeSimple[param.type]; //console.log(coder)\n\n  if (coder) {\n    return coder(coerceFunc, param.name);\n  }\n\n  var matchNumber = param.type.match(paramTypeNumber);\n\n  if (matchNumber) {\n    var size = parseInt(matchNumber[2] || 256);\n\n    if (size === 0 || size > 256 || size % 8 !== 0) {\n      errors.throwError('invalid ' + matchNumber[1] + ' bit length', errors.INVALID_ARGUMENT, {\n        arg: 'param',\n        value: param\n      });\n    }\n\n    return coderNumber(coerceFunc, size / 8, matchNumber[1] === 'int', param.name);\n  }\n\n  var matchBytes = param.type.match(paramTypeBytes);\n\n  if (matchBytes) {\n    var _size = parseInt(matchBytes[1]);\n\n    if (_size === 0 || _size > 32) {\n      errors.throwError('invalid bytes length', errors.INVALID_ARGUMENT, {\n        arg: 'param',\n        value: param\n      });\n    }\n\n    return coderFixedBytes(coerceFunc, _size, param.name);\n  }\n\n  var matchArray = param.type.match(paramTypeArray);\n\n  if (matchArray) {\n    param = shallowCopy(param);\n\n    var _size2 = parseInt(matchArray[2] || -1);\n\n    param.type = matchArray[1];\n    return coderArray(coerceFunc, getParamCoder(coerceFunc, param), _size2, param.name);\n  }\n\n  if (param.type.substring(0, 5) === 'tuple') {\n    return getTupleParamCoder(coerceFunc, param.components, param.name);\n  }\n\n  if (param.type === '') {\n    return coderNull(coerceFunc);\n  }\n\n  errors.throwError('invalid type', errors.INVALID_ARGUMENT, {\n    arg: 'type',\n    value: param.type\n  });\n}\n/**\r\n * \r\n * @param {Function} coerceFunc \r\n */\n\n\nfunction Coder(coerceFunc) {\n  if (!(this instanceof Coder)) {\n    throw new Error('missing new');\n  }\n\n  if (!coerceFunc) {\n    coerceFunc = defaultCoerceFunc;\n  }\n\n  utils.defineProperty(this, 'coerceFunc', coerceFunc);\n} // Legacy name support\n// @TODO: In the next major version, remove names from decode/encode and don't do this\n\n/**\r\n * \r\n * @param {*} type \r\n * @param {*} name \r\n * @returns \r\n */\n\n\nfunction populateNames(type, name) {\n  if (!name) {\n    return;\n  }\n\n  if (type.type.substring(0, 5) === 'tuple' && typeof name !== 'string') {\n    if (type.components.length != name.names.length) {\n      errors.throwError('names/types length mismatch', errors.INVALID_ARGUMENT, {\n        count: {\n          names: name.names.length,\n          types: type.components.length\n        },\n        value: {\n          names: name.names,\n          types: type.components\n        }\n      });\n    }\n\n    name.names.forEach(function (name, index) {\n      populateNames(type.components[index], name);\n    });\n    name = name.name || '';\n  }\n\n  if (!type.name && typeof name === 'string') {\n    type.name = name;\n  }\n}\n\nutils.defineProperty(Coder.prototype, 'encode', function (names, types, values) {\n  // Names is optional, so shift over all the parameters if not provided\n  if (arguments.length < 3) {\n    values = types;\n    types = names;\n    names = [];\n  }\n\n  if (types.length !== values.length) {\n    errors.throwError('types/values length mismatch', errors.INVALID_ARGUMENT, {\n      count: {\n        types: types.length,\n        values: values.length\n      },\n      value: {\n        types: types,\n        values: values\n      }\n    });\n  }\n\n  var coders = [];\n  types.forEach(function (type, index) {\n    // Convert types to type objects\n    //   - \"uint foo\" => { type: \"uint\", name: \"foo\" }\n    //   - \"tuple(uint, uint)\" => { type: \"tuple\", components: [ { type: \"uint\" }, { type: \"uint\" }, ] }\n    if (typeof type === 'string') {\n      type = parseParam(type);\n    } // Legacy support for passing in names (this is going away in the next major version)\n\n\n    populateNames(type, names[index]);\n    coders.push(getParamCoder(this.coerceFunc, type));\n  }, this);\n  return utils.hexlify(coderTuple(this.coerceFunc, coders).encode(values));\n});\nutils.defineProperty(Coder.prototype, 'decode', function (names, types, data) {\n  // ([],outputTypes, response)\n  // Names is optional, so shift over all the parameters if not provided\n  if (arguments.length < 3) {\n    data = types;\n    types = names;\n    names = [];\n  } //console.log(data)\n\n\n  data = utils.arrayify(data); //console.log(data)\n\n  var coders = [];\n  types.forEach(function (type, index) {\n    // See encode for details\n    if (typeof type === 'string') {\n      type = parseParam(type);\n    } // Legacy; going away in the next major version\n\n\n    populateNames(type, names[index]);\n    coders.push(getParamCoder(this.coerceFunc, type)); //console.log(10,coders[0].decode.toString())\n  }, this); //console.log(1,this.coerceFunc)\n  //console.log(2,coderTuple(this.coerceFunc, coders).decode.toString())\n\n  return coderTuple(this.coerceFunc, coders).decode(data, 0).value;\n});\nutils.defineProperty(Coder, 'defaultCoder', new Coder());\nutils.defineProperty(Coder, 'parseSignature', parseSignature);\nmodule.exports = Coder;","map":null,"metadata":{},"sourceType":"script"}