{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/asurashen/Project/ale_try/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/Users/asurashen/Project/ale_try/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/asurashen/Project/ale_try/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _asyncToGenerator = require(\"/Users/asurashen/Project/ale_try/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar crypto = require(\"crypto\");\n\nvar argon2 = require(\"argon2-wasm-pro\");\n\nvar bip39 = require(\"bip39\");\n\nvar HDKey = require(\"hdkey\");\n\nvar secp256k1 = require(\"secp256k1\");\n\nvar _require = require(\"js-sha3\"),\n    keccak256 = _require.keccak256;\n\nvar _require2 = require(\"../utils/helper/abi-coder/address\"),\n    getAddress = _require2.getAddress;\n\nvar _require3 = require(\"../utils/helper/abi-coder/convert\"),\n    arrayify = _require3.arrayify;\n\nvar toUint8Array = function toUint8Array(hexString) {\n  return new Uint8Array(hexString.match(/.{1,2}/g).map(function (byte) {\n    return parseInt(byte, 16);\n  }));\n};\n/**\r\n * Encode an account with a public key\r\n * @param {string} publicKey\r\n * @returns {string} Account\r\n */\n\n\nfunction encodeAccount(publicKey) {\n  // Zero address, special treatment\n  if (publicKey === \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\") {\n    return \"mcp_zero_address\";\n  }\n\n  var pub = \"0x\" + publicKey;\n  var newBytes = arrayify(pub);\n  var kh = keccak256(newBytes);\n  var account = \"0x\" + kh.substring(24);\n  var result = getAddress(account);\n  return result;\n}\n/**\r\n * Import account via mnemonic\r\n * @param {string} mnemonicWord\r\n * @param {string} accountPath\r\n * @returns {Promise<{account:string;private_key:string;mnemonic:string} | Error>}\r\n */\n\n\nfunction importAccountWithMnemonic(_x, _x2, _x3) {\n  return _importAccountWithMnemonic.apply(this, arguments);\n}\n/**\r\n * Create an account with a password\r\n * @param {string} mnemonicWord\r\n * @param {string} accountPath\r\n * @returns {Promise<{account:string;private_key:string;mnemonic:string} | Error>}\r\n */\n\n\nfunction _importAccountWithMnemonic() {\n  _importAccountWithMnemonic = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(mnemonicWord, accountPath, accountIndex) {\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            if (!(typeof mnemonicWord != \"string\")) {\n              _context7.next = 2;\n              break;\n            }\n\n            throw new Error(\"Unexpected type at first args. Need string but get \".concat(typeof mnemonicWord, \".\"));\n\n          case 2:\n            _context7.next = 4;\n            return createAccountWithoutPassword(mnemonicWord, accountPath, accountIndex);\n\n          case 4:\n            return _context7.abrupt(\"return\", _context7.sent);\n\n          case 5:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _importAccountWithMnemonic.apply(this, arguments);\n}\n\nfunction createAccountWithoutPassword(_x4, _x5, _x6) {\n  return _createAccountWithoutPassword.apply(this, arguments);\n}\n/**\r\n * Create an account\r\n * @param {string} password\r\n * @param {*} costNum\r\n * @param {string} privateKey\r\n * @returns {Promise<{account:string;kdf_salt:string;iv:string;ciphertext:string} | Error>}\r\n */\n\n\nfunction _createAccountWithoutPassword() {\n  _createAccountWithoutPassword = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(mnemonicWord, accountPath, accountIndex) {\n    var mnemonic, seed, master, account, addr, privateKey;\n    return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            mnemonic = mnemonicWord || bip39.generateMnemonic(128);\n            _context8.next = 3;\n            return bip39.mnemonicToSeed(mnemonic, \"\");\n\n          case 3:\n            seed = _context8.sent;\n            master = HDKey.fromMasterSeed(seed);\n            account = master.derive(accountPath);\n            addr = account.deriveChild(accountIndex);\n            privateKey = addr.privateKey;\n            return _context8.abrupt(\"return\", new Promise(function (resolve, reject) {\n              try {\n                var publicKey = secp256k1.publicKeyCreate(privateKey, false).slice(1);\n                var pub_hex = Buffer.from(publicKey, \"hex\").toString(\"hex\").toUpperCase();\n                var accFile = {\n                  account: encodeAccount(pub_hex),\n                  private_key: privateKey.toString(\"hex\").toUpperCase(),\n                  mnemonic: mnemonic\n                };\n                resolve(accFile);\n              } catch (e) {\n                reject(e);\n              }\n            }).catch(function (err) {\n              throw err;\n            }));\n\n          case 9:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n  return _createAccountWithoutPassword.apply(this, arguments);\n}\n\nfunction createAccount(_x7, _x8, _x9) {\n  return _createAccount.apply(this, arguments);\n}\n/**\r\n * Decrypt an account\r\n * @param {object} keystore\r\n * @param {string} keystore.kdf_salt\r\n * @param {string} keystore.iv\r\n * @param {string} keystore.ciphertext\r\n * @param {string} keystore.account\r\n * @param {string} password\r\n * @param {*} costNum\r\n * @returns {Promise<string>}\r\n */\n\n\nfunction _createAccount() {\n  _createAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(password, costNum, privateKey) {\n    var kdf_salt, iv, kdfOption, derivePwd, cipher, ciphertext, promise;\n    return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            kdf_salt = crypto.randomBytes(16);\n            iv = crypto.randomBytes(16);\n            privateKey = privateKey ? Buffer.from(privateKey.toUpperCase(), \"hex\") : crypto.randomBytes(32); // password hashing\n\n            kdfOption = {\n              pass: password.toString(),\n              salt: kdf_salt,\n              type: argon2.argon2id,\n              time: 1,\n              mem: costNum,\n              parallelism: 1,\n              hashLen: 32 // raw: true,\n              // version: 0x13\n\n            }; // eslint-disable-next-line no-useless-catch\n\n            _context9.prev = 4;\n            _context9.next = 7;\n            return argon2.hash(kdfOption);\n\n          case 7:\n            derivePwd = _context9.sent;\n            // Encrypted private key\n            // Encryption method aes-256-ctr\n            cipher = crypto.createCipheriv(\"aes-256-ctr\", Buffer.from(derivePwd.hash.buffer), iv);\n            ciphertext = Buffer.concat([cipher.update(privateKey), cipher.final()]);\n            promise = new Promise(function (resolve, reject) {\n              try {\n                // Generate public key\n                var publicKey = secp256k1.publicKeyCreate(privateKey, false).slice(1);\n                var pub_hex = Buffer.from(publicKey, \"hex\").toString(\"hex\").toUpperCase(); //clear privateKey for security, any better method?\n\n                crypto.randomFillSync(Buffer.from(derivePwd.hash.buffer));\n                crypto.randomFillSync(privateKey);\n                var accFile = {\n                  account: encodeAccount(pub_hex),\n                  kdf_salt: kdf_salt.toString(\"hex\").toUpperCase(),\n                  iv: iv.toString(\"hex\").toUpperCase(),\n                  ciphertext: ciphertext.toString(\"hex\").toUpperCase()\n                };\n                resolve(accFile);\n              } catch (e) {\n                reject(e);\n              }\n            });\n            return _context9.abrupt(\"return\", promise);\n\n          case 14:\n            _context9.prev = 14;\n            _context9.t0 = _context9[\"catch\"](4);\n            throw _context9.t0;\n\n          case 17:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9, null, [[4, 14]]);\n  }));\n  return _createAccount.apply(this, arguments);\n}\n\nfunction decryptAccount(_x10, _x11, _x12) {\n  return _decryptAccount.apply(this, arguments);\n}\n/**\r\n *\r\n * @param {*} block\r\n * @param {string} privateKey\r\n * @returns {Promise<string>}\r\n */\n\n\nfunction _decryptAccount() {\n  _decryptAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(keystore, password, costNum) {\n    var kdfOption, derivePwd, decipher, privateKey;\n    return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            keystore.kdf_salt = Buffer.from(keystore.kdf_salt, \"hex\");\n            keystore.iv = Buffer.from(keystore.iv, \"hex\");\n            keystore.ciphertext = Buffer.from(keystore.ciphertext, \"hex\");\n            kdfOption = {\n              pass: password.toString(),\n              salt: keystore.kdf_salt,\n              type: argon2.argon2id,\n              time: 1,\n              mem: costNum,\n              parallelism: 1,\n              hashLen: 32 // raw: true,\n              // version: 0x13\n\n            }; // password hashing\n            // eslint-disable-next-line no-useless-catch\n\n            _context10.prev = 4;\n            _context10.next = 7;\n            return argon2.hash(kdfOption);\n\n          case 7:\n            derivePwd = _context10.sent;\n            // Decrypt private key from ciphertext\n            decipher = crypto.createDecipheriv(\"aes-256-ctr\", Buffer.from(derivePwd.hash.buffer), keystore.iv);\n            privateKey = Buffer.concat([decipher.update(keystore.ciphertext), decipher.final()]);\n            return _context10.abrupt(\"return\", privateKey.toString(\"hex\").toUpperCase());\n\n          case 13:\n            _context10.prev = 13;\n            _context10.t0 = _context10[\"catch\"](4);\n            throw _context10.t0;\n\n          case 16:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10, null, [[4, 13]]);\n  }));\n  return _decryptAccount.apply(this, arguments);\n}\n\nfunction signBlock(_x13, _x14) {\n  return _signBlock.apply(this, arguments);\n}\n/**\r\n * Verify account\r\n * @param {object} keystore\r\n * @param {string} keystore.kdf_salt\r\n * @param {string} keystore.iv\r\n * @param {string} keystore.ciphertext\r\n * @param {string} keystore.account\r\n * @param {string} password\r\n * @param {*} costNum\r\n * @returns {Promise<boolean>}\r\n */\n\n\nfunction _signBlock() {\n  _signBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(block, privateKey) {\n    return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n      while (1) {\n        switch (_context12.prev = _context12.next) {\n          case 0:\n            return _context12.abrupt(\"return\", new Promise( /*#__PURE__*/function () {\n              var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(resolve, reject) {\n                var sig, signature;\n                return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n                  while (1) {\n                    switch (_context11.prev = _context11.next) {\n                      case 0:\n                        try {\n                          block = toUint8Array(block);\n                          privateKey = toUint8Array(privateKey);\n                          sig = secp256k1.ecdsaSign(block, privateKey);\n                          signature = Buffer.from(sig.signature, \"hex\").toString(\"hex\") + Buffer.from([sig.recid], \"hex\").toString(\"hex\");\n                          resolve(signature);\n                        } catch (e) {\n                          reject(e);\n                        }\n\n                      case 1:\n                      case \"end\":\n                        return _context11.stop();\n                    }\n                  }\n                }, _callee11);\n              }));\n\n              return function (_x28, _x29) {\n                return _ref.apply(this, arguments);\n              };\n            }()));\n\n          case 1:\n          case \"end\":\n            return _context12.stop();\n        }\n      }\n    }, _callee12);\n  }));\n  return _signBlock.apply(this, arguments);\n}\n\nfunction _validateAccount2(_x15, _x16, _x17) {\n  return _validateAccount.apply(this, arguments);\n}\n\nfunction _validateAccount() {\n  _validateAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(keystore, password, costNum) {\n    var prv1;\n    return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n      while (1) {\n        switch (_context13.prev = _context13.next) {\n          case 0:\n            _context13.next = 2;\n            return decryptAccount(keystore, password, costNum);\n\n          case 2:\n            prv1 = _context13.sent;\n            return _context13.abrupt(\"return\", new Promise(function (resolve, reject) {\n              try {\n                var privateKey = Buffer.from(prv1.toUpperCase(), \"hex\");\n                var publicKey = secp256k1.publicKeyCreate(privateKey, false).slice(1);\n                var pub_hex = Buffer.from(publicKey, \"hex\").toString(\"hex\").toUpperCase();\n\n                if (encodeAccount(pub_hex) === getAddress(keystore.account)) {\n                  resolve(true);\n                } else {\n                  resolve(false);\n                }\n              } catch (e) {\n                reject(e);\n              }\n            }));\n\n          case 4:\n          case \"end\":\n            return _context13.stop();\n        }\n      }\n    }, _callee13);\n  }));\n  return _validateAccount.apply(this, arguments);\n}\n\nvar Accounts = /*#__PURE__*/function () {\n  /**\r\n   * Init Accounts\r\n   * @param {boolean} dev Configuration Environment\r\n   */\n  function Accounts(dev) {\n    _classCallCheck(this, Accounts);\n\n    // if (dev) {\n    //     // test environment\n    //     this.costNum = 256;\n    // } else {\n    this.costNum = 16 * 1024; // }\n  }\n  /**\r\n   * create account\r\n   * @param password - account password\r\n   * @return {Promise{accountFile | Error}} - accountFile { account, kdf_salt, iv, ciphertext }\r\n   * */\n\n\n  _createClass(Accounts, [{\n    key: \"create\",\n    value: function create(password) {\n      if (password !== undefined) return createAccount(password, this.costNum);\n    }\n    /**\r\n     * Create an account with a password\r\n     * @param {string} accountPath\r\n     * @returns {Promise<{account:string;private_key:string;mnemonic:string} | Error>}\r\n     */\n\n  }, {\n    key: \"createWithoutMnemonic\",\n    value: function () {\n      var _createWithoutMnemonic = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(accountPath) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!accountPath) {\n                  _context.next = 4;\n                  break;\n                }\n\n                _context.next = 3;\n                return createAccountWithoutPassword(false, accountPath, 0);\n\n              case 3:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function createWithoutMnemonic(_x18) {\n        return _createWithoutMnemonic.apply(this, arguments);\n      }\n\n      return createWithoutMnemonic;\n    }()\n    /**\r\n     * Import account via mnemonic\r\n     * @param {string} mnemonicWord\r\n     * @param {string} accountPath\r\n     * @returns {Promise<{account:string;private_key:string;mnemonic:string} | Error>}\r\n     */\n\n  }, {\n    key: \"importWithMnemonic\",\n    value: function () {\n      var _importWithMnemonic = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(mnemonicWord, accountPath) {\n        var accountIndex,\n            _args2 = arguments;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                accountIndex = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : 0;\n\n                if (!(mnemonicWord && accountPath)) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                _context2.next = 4;\n                return importAccountWithMnemonic(mnemonicWord, accountPath, accountIndex);\n\n              case 4:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function importWithMnemonic(_x19, _x20) {\n        return _importWithMnemonic.apply(this, arguments);\n      }\n\n      return importWithMnemonic;\n    }()\n    /**\r\n     * Create account with private key\r\n     * @param {*} password\r\n     * @param {*} privateKey\r\n     * @returns {Promise<{account:string;kdf_salt:string;iv:string;ciphertext:string} | Error>}\r\n     */\n\n  }, {\n    key: \"createByPrivate\",\n    value: function () {\n      var _createByPrivate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(password, privateKey) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (privateKey) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", \"Private key not found\");\n\n              case 2:\n                _context3.next = 4;\n                return createAccount(password, this.costNum, privateKey);\n\n              case 4:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function createByPrivate(_x21, _x22) {\n        return _createByPrivate.apply(this, arguments);\n      }\n\n      return createByPrivate;\n    }()\n    /**\r\n     * Get account through private key\r\n     * @param {string} privateKey\r\n     * @returns {Promise<string>}\r\n     */\n\n  }, {\n    key: \"getAccountByPrivate\",\n    value: function () {\n      var _getAccountByPrivate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(privateKey) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (privateKey) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", \"Private key not found\");\n\n              case 2:\n                privateKey = Buffer.from(privateKey.toUpperCase(), \"hex\");\n                return _context4.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  try {\n                    // Create publicKey\n                    var publicKey = secp256k1.publicKeyCreate(privateKey, false).slice(1);\n                    var pub_hex = Buffer.from(publicKey, \"hex\").toString(\"hex\").toUpperCase();\n                    resolve(encodeAccount(pub_hex));\n                  } catch (e) {\n                    reject(e);\n                  }\n                }));\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function getAccountByPrivate(_x23) {\n        return _getAccountByPrivate.apply(this, arguments);\n      }\n\n      return getAccountByPrivate;\n    }()\n    /**\r\n     * Verify the keystore file\r\n     * @param {object} keystore\r\n     * @param {string} keystore.kdf_salt\r\n     * @param {string} keystore.iv\r\n     * @param {string} keystore.ciphertext\r\n     * @param {string} keystore.account\r\n     * @param {string} password\r\n     * @returns {Promise<boolean>} Validation results\r\n     */\n\n  }, {\n    key: \"validateAccount\",\n    value: function validateAccount(keystore, password) {\n      return _validateAccount2(keystore, password, this.costNum);\n    }\n    /**\r\n     * Decrypt account private key\r\n     * @param {object} keystore\r\n     * @param {string} keystore.kdf_salt\r\n     * @param {string} keystore.iv\r\n     * @param {string} keystore.ciphertext\r\n     * @param {string} keystore.account\r\n     * @param {string} password\r\n     * @returns {string} privateKey\r\n     */\n\n  }, {\n    key: \"decrypt\",\n    value: function () {\n      var _decrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(keystore, password) {\n        var isValidate;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return _validateAccount2(keystore, password, this.costNum);\n\n              case 2:\n                isValidate = _context5.sent;\n\n                if (!isValidate) {\n                  _context5.next = 7;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", decryptAccount(keystore, password, this.costNum));\n\n              case 7:\n                throw new Error(\"Parameter (password)'s value invalid\");\n\n              case 8:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function decrypt(_x24, _x25) {\n        return _decrypt.apply(this, arguments);\n      }\n\n      return decrypt;\n    }()\n    /**\r\n     * Get signature\r\n     * @param {*} block\r\n     * @param {string} privateKey\r\n     * @returns {string} signature\r\n     */\n\n  }, {\n    key: \"sign\",\n    value: function () {\n      var _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(block, privateKey) {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return signBlock(block, privateKey);\n\n              case 2:\n                return _context6.abrupt(\"return\", _context6.sent);\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n\n      function sign(_x26, _x27) {\n        return _sign.apply(this, arguments);\n      }\n\n      return sign;\n    }()\n  }]);\n\n  return Accounts;\n}();\n\nmodule.exports = Accounts;","map":null,"metadata":{},"sourceType":"script"}