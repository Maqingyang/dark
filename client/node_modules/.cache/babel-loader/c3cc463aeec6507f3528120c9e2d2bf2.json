{"ast":null,"code":"/* eslint-disable no-setter-return */\n\n/**\r\n * To initialize a contract use:\r\n *\r\n *  var Contract = require('web3-eth-contract');\r\n *  Contract.setProvider('ws://localhost:8546');\r\n *  var contract = new Contract(abi, account, ...)\r\n */\n\"use strict\"; // RPC communication\n\nvar _regeneratorRuntime = require(\"/Users/asurashen/Project/ale_try/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/asurashen/Project/ale_try/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/asurashen/Project/ale_try/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/asurashen/Project/ale_try/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar url = require('url');\n\nvar HttpRequest = require('../httprequest'); // **************\n\n\nvar utils = require(\"../utils/\");\n\nvar abi = require(\"../abi/\"); // Set request\n\n\nvar request;\nvar mcpAccounts;\n/**\r\n * Use the following method\r\n * utils._jsonInterfaceMethodToString   // Add to MCP util\r\n * utils._fireError                     // Add to MCP util\r\n * utils.isAccount(args.options.from)   // Add to MCP util\r\n * \r\n * Use the following method\r\n * abi.encodeFunctionSignature(funcName);\r\n * abi.encodeEventSignature(funcName);\r\n * abi.encodeParameters(inputs, args)\r\n * abi.decodeLog(event.inputs, data.data, argTopics);\r\n * abi.decodeParameters(outputs, returnValues);\r\n */\n\n/**\r\n * Need to create an instance when using\r\n * @method Contract\r\n * @constructor\r\n * @param {Array} jsonInterface\r\n * @param {String} account\r\n * @param {Object} options\r\n */\n\nvar Contract = /*#__PURE__*/function () {\n  /**\r\n   * \r\n   * @param {*} jsonInterface \r\n   * @param {*} account \r\n   * @param {*} options \r\n   */\n  function Contract(jsonInterface, account, options) {\n    _classCallCheck(this, Contract);\n\n    var _this = this,\n        args = Array.prototype.slice.call(arguments); // Determine if the prototype is in Contract\n    // if (!(this instanceof Contract)) {\n    //     throw new Error('Please use the \"new\" keyword to instantiate a contract object!');\n    // }\n    // Judge jsonInterface\n\n\n    if (!jsonInterface || !Array.isArray(jsonInterface)) {\n      throw new Error('You must provide the json interface of the contract when instantiating a contract object.');\n    } // create the options object\n\n\n    this.options = {};\n    this.methods = {}; // Processing parameter assignment; options and contract account\n\n    var lastArg = args[args.length - 1];\n\n    if (utils.judge(lastArg) === 'object') {\n      options = lastArg;\n      this.options = Object.assign(this.options, this._getOrSetDefaultOptions(options)); // Initialize ads\n\n      if (utils.judge(account) === 'object') {\n        account = null;\n      }\n    }\n\n    this._account = null;\n    this._jsonInterface = []; // get default account from the mci\n\n    var defaultMci = this.constructor.defaultMci || 'latest';\n    Object.defineProperty(this, 'defaultMci', {\n      get: function get() {\n        return defaultMci;\n      },\n      set: function set(val) {\n        if (val) {\n          defaultMci = val;\n        }\n\n        return defaultMci;\n      },\n      enumerable: true\n    }); // Set up an account on this.options\n\n    Object.defineProperty(this.options, 'account', {\n      set: function set(value) {\n        if (value) {\n          _this._account = value;\n        }\n\n        return _this._account;\n      },\n      get: function get() {\n        return _this._account;\n      },\n      enumerable: true\n    }); // Set jsonInterface on this.options\n\n    Object.defineProperty(this.options, 'jsonInterface', {\n      set: function set(value) {\n        // All methods\n        _this.methods = {};\n        _this._jsonInterface = value.map(function (method) {\n          var func, // Function name\n          funcName; // Function name\n          // make constant and payable backwards compatible\n          // Determine whether it is variable and whether it can be paid\n\n          method.constant = method.stateMutability === \"view\" || method.stateMutability === \"pure\" || method.constant;\n          method.payable = method.stateMutability === \"payable\" || method.payable; // Function name\n\n          if (method.name) {\n            // Typed functions testCall2(uint256,uint256)\n            funcName = utils._jsonInterfaceMethodToString(method);\n          } // function\n\n\n          if (method.type === 'function') {\n            method.signature = abi.encodeFunctionSignature(funcName); //a()\n            // console.log(\"method.signature\", method.signature);\n\n            func = _this._createTxObject && _this._createTxObject.bind({\n              method: method,\n              parent: _this\n            }); // Used to assign to XXX\n            // Only when there is no adding method\n\n            if (!_this.methods[method.name]) {\n              _this.methods[method.name] = func;\n            } else {\n              // Have the same method.name, support the setting of different parameters for the same method.name\n              var cascadeFunc = _this._createTxObject.bind({\n                method: method,\n                parent: _this,\n                nextMethod: _this.methods[method.name]\n              });\n\n              _this.methods[method.name] = cascadeFunc;\n            }\n\n            _this.methods[method.signature] = func;\n            _this.methods[funcName] = func;\n          } else if (method.type === 'event') {\n            // event\n            method.signature = abi.encodeEventSignature(funcName);\n          }\n\n          return method;\n        });\n        return _this._jsonInterface;\n      },\n      get: function get() {\n        return _this._jsonInterface;\n      },\n      enumerable: true\n    }); // set getter/setter properties\n\n    this.options.account = account;\n    this.options.jsonInterface = jsonInterface;\n  }\n  /**\r\n   * clone\r\n   * @method clone\r\n   * @return {Object} the event subscription\r\n   */\n\n\n  _createClass(Contract, [{\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor(this.options.jsonInterface, this.options.account, this.options);\n    }\n    /**\r\n     * deploy\r\n     * @method deploy\r\n     * @param {Object} options\r\n     * @return {Object} EventEmitter possible events are \"error\", \"transactionHash\" and \"receipt\"\r\n     */\n\n  }, {\n    key: \"deploy\",\n    value: function deploy(options) {\n      options = options || {};\n      options.arguments = options.arguments || [];\n      options = this._getOrSetDefaultOptions(options); // If \"data\" is not specified, an error is returned\n\n      if (!options.data) {\n        return utils._fireError(new Error('No \"data\" specified in neither the given options, nor the default options.'), null, null, null);\n      } // Find constructors, if not, then {}\n\n\n      var constructors = this.options.jsonInterface.find(function (method) {\n        return method.type === 'constructor';\n      }) || {};\n      constructors.signature = 'constructor'; // console.log(\" -------- deploy -------- \")\n      // console.log(\"constructors\", constructors)\n      // console.log('options.data ==> ', options.data)\n      // console.log('this.constructor._mcpAccounts ==> ', this.constructor._mcpAccounts)\n      // console.log('options.arguments ==> ', options.arguments)\n      // console.log(\" -------- deploy --------  \\n\");\n\n      return this._createTxObject.apply({\n        method: constructors,\n        parent: this,\n        deployData: options.data,\n        _mcpAccounts: this.constructor._mcpAccounts\n      }, options.arguments);\n    }\n    /**\r\n     * Return an object with call sendBlock encodeABI functions\r\n     * @method _createTxObject\r\n     * @returns {Object} an object with functions to call the methods\r\n     */\n\n  }, {\n    key: \"_createTxObject\",\n    value: function _createTxObject() {\n      // Convert to array\n      var args = Array.prototype.slice.call(arguments);\n      var txObject = {\n        'tag': \"mcp\"\n      }; // Encode\n      // Export bytecode\n\n      txObject.encodeABI = this.parent._encodeMethodABI.bind(txObject);\n      txObject.decodeABI = this.parent._decodeMethodABI.bind(txObject);\n      txObject.sendToBlock = this.parent._getRpc.bind(txObject, 'sendToBlock', true);\n\n      if (this.method.type === 'function') {\n        txObject.call = this.parent._getRpc.bind(txObject, 'call');\n        txObject.call.request = this.parent._getRpc.bind(txObject, 'call', true); // to make batch requests\n      }\n\n      txObject.sendBlock = this.parent._getRpc.bind(txObject, 'send'); // MCP sendBlock method\n\n      txObject.sendBlock.request = this.parent._getRpc.bind(txObject, 'send', true); // to make batch requests\n\n      if (args && this.method.inputs && args.length !== this.method.inputs.length) {\n        if (this.nextMethod) {\n          return this.nextMethod.apply(null, args);\n        }\n\n        throw \"\\n                args_length: \".concat(args.length, \",\\n                method_inputs_length: \").concat(this.method.inputs.length, \",\\n                method_name: \").concat(this.method.name, \"\\n            \");\n      }\n\n      txObject.arguments = args || [];\n      txObject._method = this.method;\n      txObject._parent = this.parent;\n      txObject._mcpAccounts = this.parent.constructor._mcpAccounts || mcpAccounts;\n\n      if (this.deployData) {\n        txObject._deployData = this.deployData;\n      }\n\n      return txObject;\n    }\n    /**\r\n     * Encode the ABI for the method, including the signature or method. Or when the constructor only encodes the constructor parameters.\r\n     * Do bytycode based on ABI\r\n     * @method _encodeMethodABI\r\n     * @param {Mixed} args the arguments to encode\r\n     * @param {String} the encoded ABI\r\n     */\n\n  }, {\n    key: \"_encodeMethodABI\",\n    value: function _encodeMethodABI() {\n      // this have call send _deployData\n      var methodSignature = this._method.signature,\n          // Passed parameters [ 0, 1 ]\n      args = this.arguments || [];\n      var signature = false;\n      var paramsABI = this._parent.options.jsonInterface.filter(function (json) {\n        return methodSignature === 'constructor' && json.type === methodSignature || (json.signature === methodSignature || json.signature === methodSignature.replace('0x', '') || json.name === methodSignature) && json.type === 'function';\n      }).map(function (json) {\n        var inputLength = utils.judge(json.inputs) === 'array' ? json.inputs.length : 0;\n\n        if (inputLength !== args.length) {\n          throw new Error('The number of arguments is not matching the methods required number. You need to pass ' + inputLength + ' arguments.');\n        }\n\n        if (json.type === 'function') {\n          signature = json.signature;\n        }\n\n        return utils.judge(json.inputs) === 'array' ? json.inputs : [];\n      }).map(function (inputs) {\n        return abi.encodeParameters(inputs, args).replace('0x', '');\n      })[0] || ''; // Methods and parameters are converted to hexadecimal\n      // return constructor\n\n      if (methodSignature === 'constructor') {\n        // When deploying\n        if (!this._deployData) {\n          throw new Error('The contract has no contract data option set. This is necessary to append the constructor parameters.');\n        }\n\n        return this._deployData + paramsABI;\n      } else {\n        var returnValue = signature ? signature + paramsABI : paramsABI;\n\n        if (!returnValue) {\n          throw new Error('Couldn\\'t find a matching contract method named \"' + this._method.name + '\".');\n        } else {\n          return returnValue;\n        }\n      }\n    }\n    /**\r\n     * _decodeMethodABI\r\n     * @param {string} encodeData encodeData\r\n     * @returns {any} method params\r\n     */\n\n  }, {\n    key: \"_decodeMethodABI\",\n    value: function _decodeMethodABI(encodeData) {\n      if (!encodeData) {\n        throw new Error('EncodeData cannot be empty.');\n      }\n\n      if (Object.prototype.toString.call(encodeData) !== '[object String]') {\n        throw new Error('EncodeData must be of type string.');\n      } // this have call send _deployData\n\n\n      encodeData = encodeData.toLowerCase();\n      encodeData = encodeData.replace('0x', '');\n      var methodSignature = this._method.signature,\n          // Passed parameters [ 0, 1 ]\n      args = this.arguments || [];\n      var signature = false;\n\n      var inputsFn = this._parent.options.jsonInterface.filter(function (json) {\n        return methodSignature === 'constructor' && json.type === methodSignature || (json.signature === methodSignature || json.signature === methodSignature.replace('0x', '') || json.name === methodSignature) && json.type === 'function';\n      }).map(function (json) {\n        var inputLength = utils.judge(json.inputs) === 'array' ? json.inputs.length : 0;\n\n        if (inputLength !== args.length) {\n          throw new Error('The number of arguments is not matching the methods required number. You need to pass ' + inputLength + ' arguments.');\n        }\n\n        if (json.type === 'function') {\n          signature = json.signature;\n        }\n\n        return utils.judge(json.inputs) === 'array' ? json : {};\n      });\n\n      if (inputsFn.length !== 1) {\n        throw new Error('Couldn\\'t find a matching contract method named \"' + this._method.name + '\".');\n      }\n\n      var inputs = inputsFn[0];\n\n      if (Object.keys(inputs) === 0) {\n        throw new Error('Couldn\\'t find a matching contract method named \"' + this._method.name + '\".');\n      }\n\n      if (methodSignature === 'constructor') {\n        // When deploying\n        if (!this._deployData) {\n          throw new Error('The contract has no contract data option set. This is necessary to append the constructor parameters.');\n        }\n\n        encodeData = encodeData.replace(this._deployData.replace('0x', ''), '');\n      } else {\n        if (signature) {\n          signature = signature.replace('0x', '');\n          encodeData = encodeData.replace(signature, '');\n        }\n      }\n\n      var retData = utils.decode.parseInputs('0x' + encodeData, inputs);\n      return retData;\n    }\n    /**\r\n     * _decodeMethodABI\r\n     * @param {string} encodeData encodeData\r\n     * @returns {any} method params\r\n     */\n\n  }, {\n    key: \"decodeABI\",\n    value: function decodeABI(encodeData) {\n      if (!encodeData) {\n        throw new Error('EncodeData cannot be empty.');\n      }\n\n      if (Object.prototype.toString.call(encodeData) !== '[object String]') {\n        throw new Error('EncodeData must be of type string.');\n      } // this have call send _deployData\n\n\n      encodeData = encodeData.toLowerCase();\n      encodeData = encodeData.replace('0x', '');\n      var methodSignature = '';\n      var signature = false;\n      var inputsFn = this.options.jsonInterface.filter(function (json) {\n        var match = json.signature && encodeData.match(json.signature.replace('0x', ''));\n\n        if (match && json.type === 'function') {\n          methodSignature = match[0];\n        }\n\n        return match && json.type === 'function';\n      }).map(function (json) {\n        if (json.type === 'function') {\n          signature = json.signature;\n        }\n\n        return utils.judge(json.inputs) === 'array' ? json : {};\n      });\n\n      if (inputsFn.length !== 1) {\n        throw new Error('Couldn\\'t find a matching contract method named.');\n      }\n\n      var inputs = inputsFn[0];\n\n      if (Object.keys(inputs) === 0) {\n        throw new Error('Couldn\\'t find a matching contract method named.');\n      }\n\n      if (signature) {\n        signature = signature.replace('0x', '');\n        encodeData = encodeData.replace(signature, '');\n      }\n\n      var retData = utils.decode.parseInputs('0x' + encodeData, inputs);\n      return {\n        parseData: retData,\n        fnInfo: inputs\n      };\n    }\n    /**\r\n     * Formatted data assembly (requires parameters on the chain)\r\n     * @method getOrSetDefaultOptions\r\n     * @param {Object} options the options gived by the user\r\n     * @return {Object} the options with gaps filled by defaults\r\n     */\n\n  }, {\n    key: \"_getOrSetDefaultOptions\",\n    value: function _getOrSetDefaultOptions(options) {\n      // console.log(\"getOrSetDefaultOptions ===> \", this.options);\n      options.from = (options.from ? options.from : null) || this.options.from;\n      options.gas_price = (options.gas_price ? String(options.gas_price) : null) || this.options.gas_price;\n      options.data = options.data || this.options.data;\n      options.gas = options.gas || this.options.gas;\n      return options;\n    }\n    /**\r\n     * \r\n     * @param {*} provider \r\n     * @param {*} accounts \r\n     */\n\n  }, {\n    key: \"_getRpc\",\n    //-------------------------------------------------------------------------------------------\n\n    /**\r\n     * Perform calls and transactions on the contract\r\n     * @method _getRpc\r\n     * @param {String} type the type this execute function should execute\r\n     * @param {Boolean} makeRequest if true, it simply returns the request parameters, rather than executing it\r\n     */\n    value: function () {\n      var _getRpc2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _this,\n            args,\n            argsOpts,\n            callOpts,\n            result,\n            opt,\n            res,\n            sendOpts,\n            sendResult,\n            _args3 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _this = this; // Initialize the parameters that need to call RPC\n\n                args = this._parent._setRpcOpt.call(this, Array.prototype.slice.call(_args3)); // console.log(\"___getRpcï¼šDo you need to request a node\", arguments)\n                // console.log(\"___Required RPC interaction\", args)\n                // console.log(\"___outputs\", this._method.outputs);\n\n                argsOpts = args.options;\n                _context3.t0 = args.type;\n                _context3.next = _context3.t0 === 'call' ? 6 : _context3.t0 === 'sendToBlock' ? 11 : _context3.t0 === 'send' ? 16 : 21;\n                break;\n\n              case 6:\n                callOpts = {\n                  from: argsOpts.from || '',\n                  to: argsOpts.to,\n                  data: argsOpts.data || '',\n                  mci: argsOpts.mci || ''\n                };\n                _context3.next = 9;\n                return request.call(callOpts);\n\n              case 9:\n                result = _context3.sent;\n                return _context3.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  if (result.code === 0) {\n                    var beautifyData = _this._parent._decodeMethodReturn(_this._method.outputs, result.output);\n\n                    _this._parent._runCallback(args.callback, null, beautifyData);\n\n                    resolve(beautifyData);\n                  } else {\n                    _this._parent._runCallback(args.callback, new Error('Call Error'));\n\n                    reject(result);\n                  }\n                }));\n\n              case 11:\n                opt = {\n                  \"from\": argsOpts.from,\n                  \"to\": argsOpts.to || \"\",\n                  \"amount\": argsOpts.amount,\n                  \"password\": argsOpts.password,\n                  \"gas\": argsOpts.gas,\n                  \"gas_price\": argsOpts.gas_price,\n                  \"data\": argsOpts.data || '',\n                  \"gen_next_work\": argsOpts.gen_next_work || '',\n                  \"id\": argsOpts.id || '',\n                  \"previous\": argsOpts.previous || ''\n                };\n                _context3.next = 14;\n                return request.sendToBlock(opt);\n\n              case 14:\n                res = _context3.sent;\n                return _context3.abrupt(\"return\", res);\n\n              case 16:\n                sendOpts = {\n                  \"from\": argsOpts.from,\n                  \"to\": argsOpts.to || \"\",\n                  \"amount\": argsOpts.amount,\n                  \"password\": argsOpts.password,\n                  \"gas\": argsOpts.gas,\n                  \"gas_price\": argsOpts.gas_price,\n                  \"data\": argsOpts.data || '',\n                  \"gen_next_work\": argsOpts.gen_next_work || '',\n                  \"id\": argsOpts.id || '',\n                  \"previous\": argsOpts.previous || ''\n                };\n                _context3.next = 19;\n                return request.sendBlock(sendOpts);\n\n              case 19:\n                sendResult = _context3.sent;\n                return _context3.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  // return\n                  if (sendResult.code !== 0) {\n                    _this._parent._runCallback(args.callback, new Error(\"Send Error\"));\n\n                    return reject(sendResult);\n                  }\n\n                  _this._parent._runCallback(args.callback, null, sendResult.hash); // Get again\n\n\n                  // Get again\n                  var searchRes;\n                  var searchTimer; // eslint-disable-next-line prefer-const\n\n                  // eslint-disable-next-line prefer-const\n                  var startSearchTimer;\n\n                  var startSearchHash = /*#__PURE__*/function () {\n                    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                      var blockResInfo, searchResBloState;\n                      return _regeneratorRuntime.wrap(function _callee$(_context) {\n                        while (1) {\n                          switch (_context.prev = _context.next) {\n                            case 0:\n                              _context.next = 2;\n                              return request.getBlockState(sendResult.hash);\n\n                            case 2:\n                              searchRes = _context.sent;\n\n                              if (!(searchRes.code !== 0)) {\n                                _context.next = 5;\n                                break;\n                              }\n\n                              return _context.abrupt(\"return\", reject(searchRes));\n\n                            case 5:\n                              if (!(searchRes.block_state.is_stable === 0)) {\n                                _context.next = 8;\n                                break;\n                              }\n\n                              _context.next = 8;\n                              return startSearchTimer();\n\n                            case 8:\n                              _context.next = 10;\n                              return request.getBlock(sendResult.hash);\n\n                            case 10:\n                              blockResInfo = _context.sent;\n\n                              if (!(blockResInfo.code !== 0)) {\n                                _context.next = 13;\n                                break;\n                              }\n\n                              return _context.abrupt(\"return\", reject(blockResInfo));\n\n                            case 13:\n                              if (searchRes.block_state.is_stable === 1) {\n                                searchResBloState = searchRes.block_state;\n                                blockResInfo.block.is_stable = searchResBloState.is_stable;\n                                blockResInfo.block.stable_content = searchResBloState.stable_content;\n                                blockResInfo.block.content.level = searchResBloState.content.level;\n                                resolve(blockResInfo);\n                              }\n\n                            case 14:\n                            case \"end\":\n                              return _context.stop();\n                          }\n                        }\n                      }, _callee);\n                    }));\n\n                    return function startSearchHash() {\n                      return _ref.apply(this, arguments);\n                    };\n                  }();\n\n                  startSearchTimer = /*#__PURE__*/function () {\n                    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n                      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                        while (1) {\n                          switch (_context2.prev = _context2.next) {\n                            case 0:\n                              _context2.next = 2;\n                              return setTimeout(startSearchHash, 1000);\n\n                            case 2:\n                              searchTimer = _context2.sent;\n\n                            case 3:\n                            case \"end\":\n                              return _context2.stop();\n                          }\n                        }\n                      }, _callee2);\n                    }));\n\n                    return function startSearchTimer() {\n                      return _ref2.apply(this, arguments);\n                    };\n                  }();\n\n                  startSearchTimer();\n                }));\n\n              case 21:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _getRpc() {\n        return _getRpc2.apply(this, arguments);\n      }\n\n      return _getRpc;\n    }()\n    /**\r\n     * Generate options to execute the call   1\r\n     * @method setRpcOpt\r\n     * @param {Array} args\r\n     * @param {Promise} defer\r\n     */\n\n  }, {\n    key: \"_setRpcOpt\",\n    value: function _setRpcOpt(args, defer) {\n      var processedArgs = {}; // console.log(`-----args1,${args}`)\n\n      processedArgs.type = args.shift(); // console.log(`-----args2,${args}, ${processedArgs.type}`)\n      // get the callback\n\n      processedArgs.callback = this._parent._getCallback(args); // get block number to use for call\n\n      if (processedArgs.type === 'call' && args[args.length - 1] !== true && (utils.judge(args[args.length - 1]) === 'string' || isFinite(args[args.length - 1]))) {\n        processedArgs.defaultMci = args.pop();\n      } // get the options\n\n\n      processedArgs.options = utils.judge(args[args.length - 1]) === 'object' ? args.pop() : {};\n      processedArgs.options = this._parent._getOrSetDefaultOptions(processedArgs.options);\n      processedArgs.options.data = this.encodeABI(); // add contract account\n\n      if (!this._deployData && !utils.isAccount(this._parent.options.account)) {\n        throw new Error('This contract object doesn\\'t have account set yet, please set an account first.');\n      } // If there is no deployed contract, the incoming ads will be used as a contract that needs to be called\n\n\n      if (!this._deployData) {\n        processedArgs.options.to = this._parent.options.account;\n      } // If \"data\" is not specified, an error is returned\n\n\n      if (!processedArgs.options.data) {\n        return utils._fireError(new Error('Couldn\\'t find a matching contract method, or the number of parameters is wrong.'), defer.eventEmitter, defer.reject, processedArgs.callback);\n      }\n\n      return processedArgs;\n    }\n    /**\r\n     * Get the callback and modify the array if necessary\r\n     * @method _getCallback\r\n     * @param {[]} args\r\n     * @return {Function} the callback\r\n     */\n\n  }, {\n    key: \"_getCallback\",\n    value: function _getCallback(args) {\n      if (args && utils.judge(args[args.length - 1]) === 'function') {\n        return args.pop(); // modify the args array!\n      }\n    }\n    /**\r\n     * @param {*} callFn \r\n     * @param {*} error \r\n     * @param {*} data \r\n     */\n\n  }, {\n    key: \"_runCallback\",\n    value: function _runCallback(callFn, error, data) {\n      if (utils.judge(callFn) === 'function') {\n        callFn(error, data);\n      }\n    }\n    /**\r\n     * Decode the returned result\r\n     * @param {*} outputs \r\n     * @param {*} returnValues \r\n     * @returns \r\n     */\n\n  }, {\n    key: \"_decodeMethodReturn\",\n    value: function _decodeMethodReturn(outputs, returnValues) {\n      //[ { name: '', type: 'uint256' }, { name: '', type: 'uint256' } ] \n      //'0x000000000000000000000000000000000000000000000000000000000000006e0000000000000000000000000000000000000000000000000000000000000077'\n      // console.log(outputs);\n      // console.log(returnValues);\n      if (!returnValues) {\n        return null;\n      } // returnValues = returnValues.length >= 2 ? returnValues.slice(2) : returnValues;\n\n\n      returnValues = returnValues.indexOf(\"0x\") === -1 ? \"0x\" + returnValues : returnValues; // You can use decode to parse\n\n      var result = abi.decodeParameters(outputs, returnValues);\n\n      if (result.__length__ === 1) {\n        return result[0];\n      } else {\n        delete result.__length__;\n        return result;\n      }\n    }\n    /**\r\n     * _decodeEventABI\r\n     * @method _decodeEventABI\r\n     * @param {object} data\r\n     * @param {string} data.id\r\n     * @param {string} data.account\r\n     * @param {string} data.data\r\n     * @param {Array} data.topics\r\n     * @param {string} data.block_hash\r\n     * @return {Object} result object with decoded indexed && not indexed params\r\n     */\n\n  }, {\n    key: \"_decodeEventABI\",\n    value: function _decodeEventABI(data) {\n      var event = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.subOptionsEvent;\n      data.id = data.id || '';\n      data.account = data.account || '';\n      data.data = data.data || '';\n      data.topics = data.topics || [];\n      data.block_hash = data.block_hash || '';\n      var result = {}; // if allEvents get the right event\n\n      if (event.name === 'ALLEVENTS') {\n        event = event.jsonInterface.find(function (intf) {\n          return intf.signature === '0x' + data.topics[0];\n        }) || {\n          anonymous: true\n        };\n      } // create empty inputs if none are present (e.g. anonymous events on allEvents)\n\n\n      event.inputs = event.inputs || []; // Handle case where an event signature shadows the current ABI with non-identical\n      // arg indexing. If # of topics doesn't match, event is anon.\n\n      if (!event.anonymous) {\n        var indexedInputs = 0;\n        event.inputs.forEach(function (input) {\n          return input.indexed ? indexedInputs++ : null;\n        });\n\n        if (indexedInputs > 0 && data.topics.length !== indexedInputs + 1) {\n          event = {\n            anonymous: true,\n            inputs: []\n          };\n        }\n      }\n\n      result.id = data.id;\n      result.account = data.account;\n      result.block_hash = data.block_hash;\n      var argTopics = event.anonymous ? data.topics : data.topics.slice(1);\n      result.returnValues = abi.decodeLog(event.inputs, data.data, argTopics);\n      delete result.returnValues.__length__; // add name\n\n      result.event = event.name; // add signature\n\n      result.signature = event.anonymous || !data.topics[0] ? null : data.topics[0]; // move the data and topics to \"raw\"\n\n      result.raw = {\n        data: data.data,\n        topics: data.topics\n      };\n      return result;\n    }\n    /**\r\n     * \r\n     * @param {*} result \r\n     * @returns \r\n     */\n\n  }, {\n    key: \"formatOutput\",\n    value: function formatOutput(result) {\n      var _this = this;\n\n      if (Array.isArray(result)) {\n        return result.map(function (res) {\n          return _this._decodeEventABI(res);\n        });\n      } else {\n        return _this._decodeEventABI(result);\n      }\n    }\n    /**\r\n     * Get past events from contracts\r\n     * @method getPastEvents\r\n     * @param {String} event\r\n     * @param {Object} options\r\n     * @param {Function} callback\r\n     * @return {Object} the promievent\r\n     */\n\n  }, {\n    key: \"getPastEvents\",\n    value: function () {\n      var _getPastEvents = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(eventName, options) {\n        var subOptions,\n            curTopic,\n            opt,\n            events,\n            _args4 = arguments;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                // console.log(eventName, options);\n                subOptions = this._generateEventOptions.apply(this, _args4); // console.log(\"subOptions\", subOptions)\n\n                curTopic = [];\n                subOptions.params.topics.forEach(function (item) {\n                  curTopic.push(item.indexOf(\"0x\") === 0 ? item.slice(2) : item);\n                });\n                opt = {\n                  \"from_stable_block_index\": options.from_stable_block_index || 0,\n                  \"to_stable_block_index\": options.to_stable_block_index,\n                  \"account\": subOptions.params.account || '',\n                  \"topics\": curTopic || ''\n                }; // console.log(\"opt\", opt);\n\n                _context4.next = 6;\n                return request.logs(opt);\n\n              case 6:\n                events = _context4.sent;\n                this.subOptionsEvent = subOptions.event;\n                return _context4.abrupt(\"return\", this.formatOutput(events.logs));\n\n              case 9:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getPastEvents(_x, _x2) {\n        return _getPastEvents.apply(this, arguments);\n      }\n\n      return getPastEvents;\n    }()\n    /**\r\n     * Gets the event signature and outputformatters\r\n     * @method generateEventOptions\r\n     * @param {Object} event\r\n     * @param {Object} options\r\n     * @param {Function} callback\r\n     * @return {Object} the event options object\r\n     */\n\n  }, {\n    key: \"_generateEventOptions\",\n    value: function _generateEventOptions() {\n      var args = Array.prototype.slice.call(arguments); // get the callback\n\n      var callback = this._getCallback(args); // get the options\n\n\n      var options = utils.judge(args[args.length - 1]) === 'object' ? args.pop() : {};\n      var event = utils.judge(args[0]) === 'string' ? args[0] : 'allevents';\n      event = event.toLowerCase() === 'allevents' ? {\n        name: 'ALLEVENTS',\n        jsonInterface: this.options.jsonInterface\n      } : this.options.jsonInterface.find(function (json) {\n        return json.type === 'event' && (json.name === event || json.signature === '0x' + event.replace('0x', ''));\n      });\n\n      if (!event) {\n        throw new Error('Event \"' + event.name + '\" doesn\\'t exist in this contract.');\n      }\n\n      if (!utils.isAccount(this.options.account)) {\n        throw new Error('This contract object doesn\\'t have account set yet, please set an account first.');\n      }\n\n      return {\n        params: this._encodeEventABI(event, options),\n        event: event,\n        callback: callback\n      };\n    }\n    /**\r\n     * Should be used to encode indexed params and options to one final object\r\n     * @method _encodeEventABI\r\n     * @param {Object} event\r\n     * @param {Object} options\r\n     * @return {Object} everything combined together and encoded\r\n     */\n\n  }, {\n    key: \"_encodeEventABI\",\n    value: function _encodeEventABI(event, options) {\n      options = options || {};\n      var filter = options.filter || {},\n          result = {}; // use given topics\n\n      if (utils.judge(options.topics) === 'array') {\n        result.topics = options.topics; // create topics based on filter\n      } else {\n        result.topics = []; // add event signature\n\n        if (event && !event.anonymous && event.name !== 'ALLEVENTS') {\n          result.topics.push(event.signature);\n        } // add event topics (indexed arguments)\n        // console.log(\"event.name\", event.name)\n        // console.log(\"event.inputs\", event.inputs)\n\n\n        if (event.name !== 'ALLEVENTS') {\n          var indexedTopics = event.inputs.filter(function (i) {\n            return i.indexed === true;\n          }).map(function (i) {\n            var value = filter[i.name];\n\n            if (!value) {\n              return null;\n            } // TODO: https://github.com/ethereum/web3.js/issues/344\n            // TODO: deal properly with components\n\n\n            if (utils.judge(value) === 'array') {\n              return value.map(function (v) {\n                return abi.encodeParameter(i.type, v);\n              });\n            }\n\n            return abi.encodeParameter(i.type, value);\n          });\n          result.topics = result.topics.concat(indexedTopics);\n        } // if (!result.topics.length) {\n        //     delete result.topics;\n        // }\n\n      }\n\n      if (this.options.account) {\n        result.account = this.options.account;\n      }\n\n      return result;\n    } //******************************************************************************************* */\n\n  }], [{\n    key: \"setProvider\",\n    value: function setProvider(provider, accounts) {\n      var parseUrlObj = url.parse(provider);\n      var opt = {\n        host: parseUrlObj.hostname,\n        port: parseUrlObj.port\n      };\n      request = new HttpRequest(opt);\n      mcpAccounts = accounts;\n    }\n  }]);\n\n  return Contract;\n}();\n\nmodule.exports = Contract;","map":null,"metadata":{},"sourceType":"script"}