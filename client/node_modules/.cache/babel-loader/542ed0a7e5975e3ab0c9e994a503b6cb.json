{"ast":null,"code":"var http = require('http');\n\nvar https = require('https');\n/* \n * Rpc Client Object\n * new Client (options)\n *  - options: json options object\n *\n *  Define: json options object: {\n *    port: int port of rpc server, default 5080 for http or 5433 for https\n *    host: string domain name or ip of rpc server, default '127.0.0.1'\n *    path: string with default path, default '/'\n *\n *    login: string rpc login name, default null\n *    hash: string rpc password (hash), default null\n *\n *    ssl: json ssl object, default null\n *\n *    Define: 'json ssl object: {\n *      ca: array of string with ca's to use, default null\n *      key: string with private key to use, default null\n *      pfx: string with key, cert and ca info in PFX format, default null\n *      cert: string with the public x509 certificate to use, default null\n *      strict: boolean false to disable remote cert verification, default true\n *      passphrase: string passphrase to be used to acces key or pfx, default null\n\n *      protocol: string ssl protocol to use, default 'SSLv3_client_method'\n *      sniName: string name for Server Name Indication, default 'RPC-Server'\n *    }\n *  }\n */\n\n\nvar Client = function Client(options) {\n  var serv, agent;\n  var self = this;\n  options = options || {};\n  var conf = {\n    host: options.host || '127.0.0.1',\n    path: options.path || '/',\n    hash: options.hash || null,\n    login: options.login || null\n  };\n\n  if (options.ssl) {\n    conf.ssl = {\n      sniName: options.ssl.sniName || 'RPC-Server',\n      protocol: options.ssl.protocol || 'SSLv3_client_method'\n    };\n\n    if (options.ssl.pfx) {\n      conf.ssl.pfx = options.ssl.pfx;\n      conf.ssl.strict = options.ssl.strict || true;\n    } else {\n      if (options.ssl.ca) {\n        conf.ssl.ca = options.ssl.ca;\n        conf.ssl.strict = options.ssl.strict || true;\n      }\n\n      if (options.ssl.key && options.ssl.cert) {\n        conf.ssl.key = options.ssl.key;\n        conf.ssl.cert = options.ssl.certs;\n      }\n    }\n\n    if (options.ssl.passphrase) {\n      conf.ssl.passphrase = options.ssl.passphrase;\n    }\n  }\n\n  if (conf.ssl) {\n    serv = https;\n    agent = new https.Agent();\n    conf.port = options.port || 5433;\n  } else {\n    serv = http;\n    agent = new http.Agent();\n    conf.port = options.port || 8765;\n  }\n  /* Private: Returns options object for http request */\n\n\n  var buildOptions = function buildOptions(opts) {\n    var options = {\n      agent: agent,\n      method: opts.method,\n      host: conf.host,\n      port: conf.port,\n      path: opts.path,\n      headers: {\n        'host': conf.host + ':' + conf.port,\n        'content-type': 'application/json',\n        'content-length': opts.length\n      }\n    };\n    if (opts.login && opts.hash) options.auth = opts.login + ':' + opts.hash;\n\n    if (conf.ssl) {\n      options.servername = conf.ssl.sniName || 'RPC-Server';\n      options.secureProtocol = conf.ssl.protocol || 'SSLv3_client_method';\n\n      if (conf.ssl.pfx) {\n        options.pfx = conf.ssl.pfx;\n        options.rejectUnauthorized = conf.ssl.strict || true;\n      } else {\n        if (conf.ssl.key && conf.ssl.cert) {\n          options.key = conf.ssl.key;\n          options.cert = conf.ssl.cert;\n        }\n\n        if (conf.ssl.ca) {\n          options.ca = conf.ssl.ca;\n          options.rejectUnauthorized = conf.ssl.strict || true;\n        }\n      }\n\n      if (conf.ssl.passphrase) options.passphrase = conf.ssl.passphrase;\n    }\n\n    return options;\n  };\n  /* \n   * Public: Call a function on remote server.\n   *  - data: json request object, required\n   *  - callback: function (error, result) -> null, required\n   *  - opts: json options object, default {}\n   *\n   *  Define: '' {\n   *    path: string request path, defaul '/'\n   *    method: string request method, default 'POST'\n   *\n   *    hash: string user password, default null\n   *    login: string user login name, default null\n   *  }\n   */\n\n\n  this.call = function (data, callback, opts) {\n    opts = opts || {};\n    var body = JSON.stringify(data);\n    var buf = Buffer.from(body, 'utf8');\n    var options = buildOptions({\n      length: buf.length,\n      method: opts.method || 'POST',\n      path: opts.path || conf.path,\n      login: opts.login || conf.login,\n      hash: opts.hash || conf.hash\n    });\n    var request = serv.request(options);\n    request.on('error', function (error) {\n      //TODO Proccess Request Error\n      // console.error(`The request encountered a problem: ${error.message}`);\n      callback(error);\n      return; // throw new Error(error.message);\n    });\n    request.on('response', function (response) {\n      var data = '';\n      response.on('data', function (bytes) {\n        data += bytes;\n      });\n      response.on('end', function () {\n        var error, result; //TODO Deal with 401 and other codes\n\n        if (response.statusCode === 200 || response.statusCode === 304) {\n          if (data.length > 0) {\n            try {\n              result = JSON.parse(data);\n            } catch (err) {\n              error = err;\n              console.error(\"Client error: failed to parse response from server.\");\n            }\n          }\n        } else console.log(\"Client: TODO Status Code: \" + response.statusCode);\n\n        callback(error, result);\n      });\n    });\n    request.end(body);\n  };\n\n  options = null;\n};\n\nmodule.exports = Client;","map":null,"metadata":{},"sourceType":"script"}