{"ast":null,"code":"var Module = typeof self !== \"undefined\" && typeof self.Module !== \"undefined\" ? self.Module : {};\nvar moduleOverrides = {};\nvar key;\n\nfor (key in Module) {\n  if (Module.hasOwnProperty(key)) {\n    moduleOverrides[key] = Module[key];\n  }\n}\n\nModule[\"arguments\"] = [];\nModule[\"thisProgram\"] = \"./this.program\";\n\nModule[\"quit\"] = function (status, toThrow) {\n  throw toThrow;\n};\n\nModule[\"preRun\"] = [];\nModule[\"postRun\"] = [];\nvar ENVIRONMENT_IS_WEB = false;\nvar ENVIRONMENT_IS_WORKER = false;\nvar ENVIRONMENT_IS_NODE = false;\nvar ENVIRONMENT_HAS_NODE = false;\nvar ENVIRONMENT_IS_SHELL = false;\nENVIRONMENT_IS_WEB = typeof window === \"object\";\nENVIRONMENT_IS_WORKER = typeof importScripts === \"function\";\nENVIRONMENT_HAS_NODE = typeof process === \"object\" && typeof process.versions === \"object\" && typeof process.versions.node === \"string\";\nENVIRONMENT_IS_NODE = ENVIRONMENT_HAS_NODE && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;\nENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\nvar scriptDirectory = \"\";\n\nif (ENVIRONMENT_IS_NODE) {\n  scriptDirectory = __dirname + \"/\";\n\n  if (process[\"argv\"].length > 1) {\n    Module[\"thisProgram\"] = process[\"argv\"][1].replace(/\\\\/g, \"/\");\n  }\n\n  Module[\"arguments\"] = process[\"argv\"].slice(2);\n\n  if (typeof module !== \"undefined\") {\n    module[\"exports\"] = Module;\n  }\n\n  process[\"on\"](\"uncaughtException\", function (ex) {\n    if (!(ex instanceof ExitStatus)) {\n      throw ex;\n    }\n  });\n  process[\"on\"](\"unhandledRejection\", abort);\n\n  Module[\"quit\"] = function (status) {\n    process[\"exit\"](status);\n  };\n\n  Module[\"inspect\"] = function () {\n    return \"[Emscripten Module object]\";\n  };\n} else if (ENVIRONMENT_IS_SHELL) {\n  if (typeof scriptArgs != \"undefined\") {\n    Module[\"arguments\"] = scriptArgs;\n  } else if (typeof arguments != \"undefined\") {\n    Module[\"arguments\"] = arguments;\n  }\n\n  if (typeof quit === \"function\") {\n    Module[\"quit\"] = function (status) {\n      quit(status);\n    };\n  }\n} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n  if (ENVIRONMENT_IS_WORKER) {\n    scriptDirectory = self.location.href;\n  } else if (document.currentScript) {\n    scriptDirectory = document.currentScript.src;\n  }\n\n  if (scriptDirectory.indexOf(\"blob:\") !== 0) {\n    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf(\"/\") + 1);\n  } else {\n    scriptDirectory = \"\";\n  }\n} else {}\n\nvar out = Module[\"print\"] || (typeof console !== \"undefined\" ? console.log.bind(console) : typeof print !== \"undefined\" ? print : null);\nvar err = Module[\"printErr\"] || (typeof printErr !== \"undefined\" ? printErr : typeof console !== \"undefined\" && console.warn.bind(console) || out);\n\nfor (key in moduleOverrides) {\n  if (moduleOverrides.hasOwnProperty(key)) {\n    Module[key] = moduleOverrides[key];\n  }\n}\n\nmoduleOverrides = undefined;\n\nfunction dynamicAlloc(size) {\n  var ret = HEAP32[DYNAMICTOP_PTR >> 2];\n  var end = ret + size + 15 & -16;\n\n  if (end > _emscripten_get_heap_size()) {\n    abort();\n  }\n\n  HEAP32[DYNAMICTOP_PTR >> 2] = end;\n  return ret;\n}\n\nfunction getNativeTypeSize(type) {\n  switch (type) {\n    case \"i1\":\n    case \"i8\":\n      return 1;\n\n    case \"i16\":\n      return 2;\n\n    case \"i32\":\n      return 4;\n\n    case \"i64\":\n      return 8;\n\n    case \"float\":\n      return 4;\n\n    case \"double\":\n      return 8;\n\n    default:\n      {\n        if (type[type.length - 1] === \"*\") {\n          return 4;\n        } else if (type[0] === \"i\") {\n          var bits = parseInt(type.substr(1));\n          assert(bits % 8 === 0, \"getNativeTypeSize invalid bits \" + bits + \", type \" + type);\n          return bits / 8;\n        } else {\n          return 0;\n        }\n      }\n  }\n}\n\nvar asm2wasmImports = {\n  \"f64-rem\": function f64Rem(x, y) {\n    return x % y;\n  },\n  \"debugger\": function _debugger() {\n    debugger;\n  }\n};\n\nif (typeof WebAssembly !== \"object\") {\n  err(\"no native wasm support detected\");\n}\n\nfunction setValue(ptr, value, type, noSafe) {\n  type = type || \"i8\";\n  if (type.charAt(type.length - 1) === \"*\") type = \"i32\";\n\n  switch (type) {\n    case \"i1\":\n      HEAP8[ptr >> 0] = value;\n      break;\n\n    case \"i8\":\n      HEAP8[ptr >> 0] = value;\n      break;\n\n    case \"i16\":\n      HEAP16[ptr >> 1] = value;\n      break;\n\n    case \"i32\":\n      HEAP32[ptr >> 2] = value;\n      break;\n\n    case \"i64\":\n      tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];\n      break;\n\n    case \"float\":\n      HEAPF32[ptr >> 2] = value;\n      break;\n\n    case \"double\":\n      HEAPF64[ptr >> 3] = value;\n      break;\n\n    default:\n      abort(\"invalid type for setValue: \" + type);\n  }\n}\n\nvar wasmMemory;\nvar ABORT = false;\n\nfunction assert(condition, text) {\n  if (!condition) {\n    abort(\"Assertion failed: \" + text);\n  }\n}\n\nvar ALLOC_NORMAL = 0;\nvar ALLOC_NONE = 3;\n\nfunction allocate(slab, types, allocator, ptr) {\n  var zeroinit, size;\n\n  if (typeof slab === \"number\") {\n    zeroinit = true;\n    size = slab;\n  } else {\n    zeroinit = false;\n    size = slab.length;\n  }\n\n  var singleType = typeof types === \"string\" ? types : null;\n  var ret;\n\n  if (allocator == ALLOC_NONE) {\n    ret = ptr;\n  } else {\n    ret = [_malloc, stackAlloc, dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));\n  }\n\n  if (zeroinit) {\n    var stop;\n    ptr = ret;\n    assert((ret & 3) == 0);\n    stop = ret + (size & ~3);\n\n    for (; ptr < stop; ptr += 4) {\n      HEAP32[ptr >> 2] = 0;\n    }\n\n    stop = ret + size;\n\n    while (ptr < stop) {\n      HEAP8[ptr++ >> 0] = 0;\n    }\n\n    return ret;\n  }\n\n  if (singleType === \"i8\") {\n    if (slab.subarray || slab.slice) {\n      HEAPU8.set(slab, ret);\n    } else {\n      HEAPU8.set(new Uint8Array(slab), ret);\n    }\n\n    return ret;\n  }\n\n  var i = 0,\n      type,\n      typeSize,\n      previousType;\n\n  while (i < size) {\n    var curr = slab[i];\n    type = singleType || types[i];\n\n    if (type === 0) {\n      i++;\n      continue;\n    }\n\n    if (type == \"i64\") type = \"i32\";\n    setValue(ret + i, curr, type);\n\n    if (previousType !== type) {\n      typeSize = getNativeTypeSize(type);\n      previousType = type;\n    }\n\n    i += typeSize;\n  }\n\n  return ret;\n}\n\nvar UTF8Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n\nfunction UTF8ArrayToString(u8Array, idx, maxBytesToRead) {\n  var endIdx = idx + maxBytesToRead;\n  var endPtr = idx;\n\n  while (u8Array[endPtr] && !(endPtr >= endIdx)) {\n    ++endPtr;\n  }\n\n  if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\n    return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));\n  } else {\n    var str = \"\";\n\n    while (idx < endPtr) {\n      var u0 = u8Array[idx++];\n\n      if (!(u0 & 128)) {\n        str += String.fromCharCode(u0);\n        continue;\n      }\n\n      var u1 = u8Array[idx++] & 63;\n\n      if ((u0 & 224) == 192) {\n        str += String.fromCharCode((u0 & 31) << 6 | u1);\n        continue;\n      }\n\n      var u2 = u8Array[idx++] & 63;\n\n      if ((u0 & 240) == 224) {\n        u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n      } else {\n        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u8Array[idx++] & 63;\n      }\n\n      if (u0 < 65536) {\n        str += String.fromCharCode(u0);\n      } else {\n        var ch = u0 - 65536;\n        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n      }\n    }\n  }\n\n  return str;\n}\n\nfunction UTF8ToString(ptr, maxBytesToRead) {\n  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\n}\n\nvar WASM_PAGE_SIZE = 65536;\n\nfunction alignUp(x, multiple) {\n  if (x % multiple > 0) {\n    x += multiple - x % multiple;\n  }\n\n  return x;\n}\n\nvar buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n\nfunction updateGlobalBufferViews() {\n  Module[\"HEAP8\"] = HEAP8 = new Int8Array(buffer);\n  Module[\"HEAP16\"] = HEAP16 = new Int16Array(buffer);\n  Module[\"HEAP32\"] = HEAP32 = new Int32Array(buffer);\n  Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(buffer);\n  Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(buffer);\n  Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(buffer);\n  Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(buffer);\n  Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(buffer);\n}\n\nvar DYNAMIC_BASE = 5248528,\n    DYNAMICTOP_PTR = 5616;\nvar TOTAL_STACK = 5242880;\nvar INITIAL_TOTAL_MEMORY = Module[\"TOTAL_MEMORY\"] || 16777216;\nif (INITIAL_TOTAL_MEMORY < TOTAL_STACK) err(\"TOTAL_MEMORY should be larger than TOTAL_STACK, was \" + INITIAL_TOTAL_MEMORY + \"! (TOTAL_STACK=\" + TOTAL_STACK + \")\");\n\nif (Module[\"wasmMemory\"]) {\n  wasmMemory = Module[\"wasmMemory\"];\n} else {\n  wasmMemory = new WebAssembly.Memory({\n    \"initial\": INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE,\n    \"maximum\": 2147418112 / WASM_PAGE_SIZE\n  });\n}\n\nif (wasmMemory) {\n  buffer = wasmMemory.buffer;\n}\n\nINITIAL_TOTAL_MEMORY = buffer.byteLength;\nupdateGlobalBufferViews();\nHEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;\n\nfunction callRuntimeCallbacks(callbacks) {\n  while (callbacks.length > 0) {\n    var callback = callbacks.shift();\n\n    if (typeof callback == \"function\") {\n      callback();\n      continue;\n    }\n\n    var func = callback.func;\n\n    if (typeof func === \"number\") {\n      if (callback.arg === undefined) {\n        Module[\"dynCall_v\"](func);\n      } else {\n        Module[\"dynCall_vi\"](func, callback.arg);\n      }\n    } else {\n      func(callback.arg === undefined ? null : callback.arg);\n    }\n  }\n}\n\nvar __ATPRERUN__ = [];\nvar __ATINIT__ = [];\nvar __ATMAIN__ = [];\nvar __ATPOSTRUN__ = [];\n\nfunction preRun() {\n  if (Module[\"preRun\"]) {\n    if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [Module[\"preRun\"]];\n\n    while (Module[\"preRun\"].length) {\n      addOnPreRun(Module[\"preRun\"].shift());\n    }\n  }\n\n  callRuntimeCallbacks(__ATPRERUN__);\n}\n\nfunction initRuntime() {\n  callRuntimeCallbacks(__ATINIT__);\n}\n\nfunction preMain() {\n  callRuntimeCallbacks(__ATMAIN__);\n}\n\nfunction postRun() {\n  if (Module[\"postRun\"]) {\n    if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [Module[\"postRun\"]];\n\n    while (Module[\"postRun\"].length) {\n      addOnPostRun(Module[\"postRun\"].shift());\n    }\n  }\n\n  callRuntimeCallbacks(__ATPOSTRUN__);\n}\n\nfunction addOnPreRun(cb) {\n  __ATPRERUN__.unshift(cb);\n}\n\nfunction addOnPostRun(cb) {\n  __ATPOSTRUN__.unshift(cb);\n}\n\nvar Math_abs = Math.abs;\nvar Math_ceil = Math.ceil;\nvar Math_floor = Math.floor;\nvar Math_min = Math.min;\nvar runDependencies = 0;\nvar runDependencyWatcher = null;\nvar dependenciesFulfilled = null;\n\nfunction addRunDependency(id) {\n  runDependencies++;\n\n  if (Module[\"monitorRunDependencies\"]) {\n    Module[\"monitorRunDependencies\"](runDependencies);\n  }\n}\n\nfunction removeRunDependency(id) {\n  runDependencies--;\n\n  if (Module[\"monitorRunDependencies\"]) {\n    Module[\"monitorRunDependencies\"](runDependencies);\n  }\n\n  if (runDependencies == 0) {\n    if (runDependencyWatcher !== null) {\n      clearInterval(runDependencyWatcher);\n      runDependencyWatcher = null;\n    }\n\n    if (dependenciesFulfilled) {\n      var callback = dependenciesFulfilled;\n      dependenciesFulfilled = null;\n      callback();\n    }\n  }\n}\n\nModule[\"preloadedImages\"] = {};\nModule[\"preloadedAudios\"] = {};\n\nvar loadModule = require('./sources.js');\n\nfunction getBinary() {\n  try {\n    if (Module[\"wasmBinary\"]) {\n      return new Uint8Array(Module[\"wasmBinary\"]);\n    }\n\n    return loadModule;\n  } catch (err) {\n    abort(err);\n  }\n}\n\nfunction getBinaryPromise() {\n  return new Promise(function (resolve, reject) {\n    resolve(getBinary());\n  });\n}\n\nfunction createWasm(env) {\n  var info = {\n    \"env\": env,\n    \"global\": {\n      \"NaN\": NaN,\n      Infinity: Infinity\n    },\n    \"global.Math\": Math,\n    \"asm2wasm\": asm2wasmImports\n  };\n\n  function receiveInstance(instance, module) {\n    var exports = instance.exports;\n    Module[\"asm\"] = exports;\n    removeRunDependency(\"wasm-instantiate\");\n  }\n\n  addRunDependency(\"wasm-instantiate\");\n\n  function receiveInstantiatedSource(output) {\n    receiveInstance(output[\"instance\"]);\n  }\n\n  function instantiateArrayBuffer(receiver) {\n    return getBinaryPromise().then(function (binary) {\n      return WebAssembly.instantiate(binary, info);\n    }).then(receiver, function (reason) {\n      err(\"failed to asynchronously prepare wasm: \" + reason);\n      abort(reason);\n    });\n  }\n\n  function instantiateAsync() {\n    return instantiateArrayBuffer(receiveInstantiatedSource);\n  }\n\n  if (Module[\"instantiateWasm\"]) {\n    try {\n      var exports = Module[\"instantiateWasm\"](info, receiveInstance);\n      return exports;\n    } catch (e) {\n      err(\"Module.instantiateWasm callback failed with error: \" + e);\n      return false;\n    }\n  }\n\n  instantiateAsync();\n  return {};\n}\n\nModule[\"asm\"] = function (global, env, providedBuffer) {\n  env[\"memory\"] = wasmMemory;\n  env[\"table\"] = new WebAssembly.Table({\n    \"initial\": 11,\n    \"maximum\": 11,\n    \"element\": \"anyfunc\"\n  });\n  env[\"__memory_base\"] = 1024;\n  env[\"__table_base\"] = 0;\n  var exports = createWasm(env);\n  return exports;\n};\n\nvar tempDouble;\nvar tempI64;\n\nfunction _emscripten_get_heap_size() {\n  return HEAP8.length;\n}\n\nfunction _emscripten_memcpy_big(dest, src, num) {\n  HEAPU8.set(HEAPU8.subarray(src, src + num), dest);\n}\n\nfunction _pthread_create() {\n  return 11;\n}\n\nfunction _exit(status) {\n  exit(status);\n}\n\nfunction _pthread_exit(status) {\n  _exit(status);\n}\n\nfunction _pthread_join() {}\n\nfunction ___setErrNo(value) {\n  if (Module[\"___errno_location\"]) HEAP32[Module[\"___errno_location\"]() >> 2] = value;\n  return value;\n}\n\nfunction abortOnCannotGrowMemory(requestedSize) {\n  abort(\"OOM\");\n}\n\nfunction emscripten_realloc_buffer(size) {\n  var PAGE_MULTIPLE = 65536;\n  size = alignUp(size, PAGE_MULTIPLE);\n  var oldSize = buffer.byteLength;\n\n  try {\n    var result = wasmMemory.grow((size - oldSize) / 65536);\n\n    if (result !== (-1 | 0)) {\n      buffer = wasmMemory.buffer;\n      return true;\n    } else {\n      return false;\n    }\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _emscripten_resize_heap(requestedSize) {\n  var oldSize = _emscripten_get_heap_size();\n\n  var PAGE_MULTIPLE = 65536;\n  var LIMIT = 2147483648 - PAGE_MULTIPLE;\n\n  if (requestedSize > LIMIT) {\n    return false;\n  }\n\n  var MIN_TOTAL_MEMORY = 16777216;\n  var newSize = Math.max(oldSize, MIN_TOTAL_MEMORY);\n\n  while (newSize < requestedSize) {\n    if (newSize <= 536870912) {\n      newSize = alignUp(2 * newSize, PAGE_MULTIPLE);\n    } else {\n      newSize = Math.min(alignUp((3 * newSize + 2147483648) / 4, PAGE_MULTIPLE), LIMIT);\n    }\n  }\n\n  newSize = Math.min(newSize, 2147418112);\n\n  if (newSize == oldSize) {\n    return false;\n  }\n\n  if (!emscripten_realloc_buffer(newSize)) {\n    return false;\n  }\n\n  updateGlobalBufferViews();\n  return true;\n}\n\nvar asmGlobalArg = {};\nvar asmLibraryArg = {\n  \"b\": abort,\n  \"c\": ___setErrNo,\n  \"j\": _emscripten_get_heap_size,\n  \"i\": _emscripten_memcpy_big,\n  \"h\": _emscripten_resize_heap,\n  \"g\": _pthread_create,\n  \"f\": _pthread_exit,\n  \"e\": _pthread_join,\n  \"d\": abortOnCannotGrowMemory,\n  \"a\": DYNAMICTOP_PTR\n};\nvar asm = Module[\"asm\"](asmGlobalArg, asmLibraryArg, buffer);\nModule[\"asm\"] = asm;\n\nModule[\"_argon2_error_message\"] = function () {\n  return Module[\"asm\"][\"k\"].apply(null, arguments);\n};\n\nModule[\"_argon2_hash\"] = function () {\n  return Module[\"asm\"][\"l\"].apply(null, arguments);\n};\n\nModule[\"_argon2_verify\"] = function () {\n  return Module[\"asm\"][\"m\"].apply(null, arguments);\n};\n\nModule[\"_free\"] = function () {\n  return Module[\"asm\"][\"n\"].apply(null, arguments);\n};\n\nvar _malloc = Module[\"_malloc\"] = function () {\n  return Module[\"asm\"][\"o\"].apply(null, arguments);\n};\n\nvar stackAlloc = Module[\"stackAlloc\"] = function () {\n  return Module[\"asm\"][\"p\"].apply(null, arguments);\n};\n\nModule[\"asm\"] = asm;\nModule[\"allocate\"] = allocate;\nModule[\"UTF8ToString\"] = UTF8ToString;\nModule[\"ALLOC_NORMAL\"] = ALLOC_NORMAL;\n\nfunction ExitStatus(status) {\n  this.name = \"ExitStatus\";\n  this.message = \"Program terminated with exit(\" + status + \")\";\n  this.status = status;\n}\n\nExitStatus.prototype = new Error();\nExitStatus.prototype.constructor = ExitStatus;\n\ndependenciesFulfilled = function runCaller() {\n  if (!Module[\"calledRun\"]) run();\n  if (!Module[\"calledRun\"]) dependenciesFulfilled = runCaller;\n};\n\nfunction run(args) {\n  args = args || Module[\"arguments\"];\n\n  if (runDependencies > 0) {\n    return;\n  }\n\n  preRun();\n  if (runDependencies > 0) return;\n  if (Module[\"calledRun\"]) return;\n\n  function doRun() {\n    if (Module[\"calledRun\"]) return;\n    Module[\"calledRun\"] = true;\n    if (ABORT) return;\n    initRuntime();\n    preMain();\n    if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n    postRun();\n  }\n\n  if (Module[\"setStatus\"]) {\n    Module[\"setStatus\"](\"Running...\");\n    setTimeout(function () {\n      setTimeout(function () {\n        Module[\"setStatus\"](\"\");\n      }, 1);\n      doRun();\n    }, 1);\n  } else {\n    doRun();\n  }\n}\n\nModule[\"run\"] = run;\n\nfunction exit(status, implicit) {\n  if (implicit && Module[\"noExitRuntime\"] && status === 0) {\n    return;\n  }\n\n  if (Module[\"noExitRuntime\"]) {} else {\n    ABORT = true;\n    if (Module[\"onExit\"]) Module[\"onExit\"](status);\n  }\n\n  Module[\"quit\"](status, new ExitStatus(status));\n}\n\nfunction abort(what) {\n  if (Module[\"onAbort\"]) {\n    Module[\"onAbort\"](what);\n  }\n\n  what += \"\";\n  out(what);\n  err(what);\n  ABORT = true;\n  throw \"abort(\" + what + \"). Build with -s ASSERTIONS=1 for more info.\";\n}\n\nModule[\"abort\"] = abort;\n\nif (Module[\"preInit\"]) {\n  if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [Module[\"preInit\"]];\n\n  while (Module[\"preInit\"].length > 0) {\n    Module[\"preInit\"].pop()();\n  }\n}\n\nModule[\"noExitRuntime\"] = true;\nrun();\nif (typeof module !== \"undefined\") module.exports = Module;","map":null,"metadata":{},"sourceType":"script"}