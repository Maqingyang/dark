const BigNumber=require("bignumber.js").default;const Hash=require("./lib/hash");const decode=require("./helper/decode");const encode=require("./helper/encode");const secp256k1=require("secp256k1");const{getAddress}=require("./helper/abi-coder/address");const{arrayify}=require("./helper/abi-coder/convert");const{keccak256}=require("js-sha3");const sha256=require("js-sha256");const unitMap={none:"0",None:"0",can:"1",Can:"1",mcp:"1000000000000000000",MCP:"1000000000000000000"};const encodeAccount=function(e){if(e==="000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"){return"mcp_zero_address"}const t="0x"+e;const n=arrayify(t);const r=keccak256(n);const o="0x"+r.substring(24);const i=getAddress(o);return i};const toUint8Array=e=>{return new Uint8Array(e.match(/.{1,2}/g).map(e=>parseInt(e,16)))};const isString=function(e){return typeof e==="string"&&e.constructor===String};const isBigNumber=function(e){return e&&e.constructor&&e.constructor.name==="BigNumber"};const toBigNumber=function(e){e=e||0;if(isBigNumber(e)){return e}if(isString(e)&&(e.indexOf("0x")===0||e.indexOf("-0x")===0)){return new BigNumber(e.replace("0x",""),16)}return new BigNumber(e.toString(10),10)};const getValueOfUnit=function(e){e=e?e.toLowerCase():"mcp";const t=unitMap[e];if(t===undefined){throw new Error("This unit doesn't exists, please use the one of the following units"+JSON.stringify(unitMap,null,2))}return new BigNumber(t,10)};const fromCan=function(e,t){const n=toBigNumber(e).dividedBy(getValueOfUnit(t));return isBigNumber(e)?n:n.toString(10)};const fromCanToken=function(e,t){const n=toBigNumber(e).dividedBy(t);return isBigNumber(e)?n:n.toString(10)};const toCan=function(e,t){const n=toBigNumber(e).times(getValueOfUnit(t));return isBigNumber(e)?n:n.toString(10)};const toCanToken=function(e,t){const n=toBigNumber(e).times(t);return isBigNumber(e)?n:n.toString(10)};const isAccount=function(e){if(!e){return false}return true};const judge=function(e){const t=/\[object (\w+)\]/.exec(Object.prototype.toString.call(e));return t?t[1].toLowerCase():""};const _fireError=function(e,t,n,r){if(judge(e)==="object"&&!(e instanceof Error)&&e.data){if(judge(e.data)==="object"||judge(e.data)==="array"){e.data=JSON.stringify(e.data,null,2)}e=e.message+"\n"+e.data}if(judge(e)==="string"){e=new Error(e)}if(judge(r)==="function"){r(e)}if(judge(n)==="function"){if(t&&judge(t.listeners)==="function"&&t.listeners("error").length||judge(r)==="function"){t.catch(function(){})}setTimeout(function(){n(e)},1)}if(t&&judge(t.emit)==="function"){setTimeout(function(){t.emit("error",e);t.removeAllListeners()},1)}return t};const _jsonInterfaceMethodToString=function(e){if(judge(e)==="object"&&e.name&&e.name.indexOf("(")!==-1){return e.name}return e.name+"("+_flattenTypes(false,e.inputs).join(",")+")"};const _flattenTypes=function(o,e){const i=[];e.forEach(function(t){if(judge(t.components)==="object"){if(t.type.substring(0,5)!=="tuple"){throw new Error("components found but type is not tuple; report on GitHub")}let e="";const n=t.type.indexOf("[");if(n>=0){e=t.type.substring(n)}const r=_flattenTypes(o,t.components);if(judge(t.data)==="array"&&o){i.push("tuple("+r.join(",")+")"+e)}else if(!o){i.push("("+r.join(",")+")"+e)}else{i.push("("+r+")")}}else{i.push(t.type)}});return i};const SHA3_NULL_S="0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";const sha3=function(e){if(isBigNumber(e)){e=e.toString()}if(isHexStrict(e)&&/^0x/i.test(e.toString())){e=hexToBytes(e)}const t=Hash.keccak256(e);if(t===SHA3_NULL_S){return null}else{return t}};sha3._Hash=Hash;const isHexStrict=function(e){return(judge(e)==="string"||judge(e)==="number")&&/^(-)?0x[0-9a-f]*$/i.test(e)};const hexToBytes=function(t){t=t.toString(16);if(!isHexStrict(t)){throw new Error('Given value "'+t+'" is not a valid hex string.')}t=t.replace(/^0x/i,"");const n=[];for(let e=0;e<t.length;e+=2)n.push(parseInt(t.substr(e,2),16));return n};const sign=function(i,s){return new Promise(function(e,t){let n=sha256(i);n=toUint8Array(n);s=toUint8Array(s);const r=secp256k1.ecdsaSign(n,s);const o=Buffer.from(r.signature,"hex").toString("hex")+Buffer.from([r.recid],"hex").toString("hex");e(o)})};module.exports={isAccount:isAccount,_fireError:_fireError,_jsonInterfaceMethodToString:_jsonInterfaceMethodToString,toBigNumber:toBigNumber,isBigNumber:isBigNumber,encode:encode,decode:decode,encodeAccount:encodeAccount,fromCan:fromCan,fromCanToken:fromCanToken,toCan:toCan,toCanToken:toCanToken,judge:judge,sha3:sha3,sign:sign};