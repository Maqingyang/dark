"use strict";const crypto=require("crypto");const argon2=require("argon2-wasm-pro");const bip39=require("bip39");const HDKey=require("hdkey");const secp256k1=require("secp256k1");const{keccak256}=require("js-sha3");const{getAddress}=require("../utils/helper/abi-coder/address");const{arrayify}=require("../utils/helper/abi-coder/convert");const toUint8Array=t=>{return new Uint8Array(t.match(/.{1,2}/g).map(t=>parseInt(t,16)))};function encodeAccount(t){if(t==="000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"){return"mcp_zero_address"}const e="0x"+t;const r=arrayify(e);const c=keccak256(r);const n="0x"+c.substring(24);const o=getAddress(n);return o}async function importAccountWithMnemonic(t,e,r){if(typeof t!="string"){throw new Error(`Unexpected type at first args. Need string but get ${typeof t}.`)}return await createAccountWithoutPassword(t,e,r)}async function createAccountWithoutPassword(t,e,r){const o=t||bip39.generateMnemonic(128);const c=await bip39.mnemonicToSeed(o,"");const n=HDKey.fromMasterSeed(c);const s=n.derive(e);const a=s.deriveChild(r);const i=a.privateKey;return new Promise(function(t,e){try{const r=secp256k1.publicKeyCreate(i,false).slice(1);const c=Buffer.from(r,"hex").toString("hex").toUpperCase();const n={account:encodeAccount(c),private_key:i.toString("hex").toUpperCase(),mnemonic:o};t(n)}catch(t){e(t)}}).catch(t=>{throw t})}async function createAccount(t,e,o){const s=crypto.randomBytes(16);const a=crypto.randomBytes(16);o=o?Buffer.from(o.toUpperCase(),"hex"):crypto.randomBytes(32);const r={pass:t.toString(),salt:s,type:argon2.argon2id,time:1,mem:e,parallelism:1,hashLen:32};try{const i=await argon2.hash(r);const c=crypto.createCipheriv("aes-256-ctr",Buffer.from(i.hash.buffer),a);const u=Buffer.concat([c.update(o),c.final()]);const n=new Promise(function(t,e){try{const r=secp256k1.publicKeyCreate(o,false).slice(1);const c=Buffer.from(r,"hex").toString("hex").toUpperCase();crypto.randomFillSync(Buffer.from(i.hash.buffer));crypto.randomFillSync(o);const n={account:encodeAccount(c),kdf_salt:s.toString("hex").toUpperCase(),iv:a.toString("hex").toUpperCase(),ciphertext:u.toString("hex").toUpperCase()};t(n)}catch(t){e(t)}});return n}catch(t){throw t}}async function decryptAccount(t,e,r){t.kdf_salt=Buffer.from(t.kdf_salt,"hex");t.iv=Buffer.from(t.iv,"hex");t.ciphertext=Buffer.from(t.ciphertext,"hex");const c={pass:e.toString(),salt:t.kdf_salt,type:argon2.argon2id,time:1,mem:r,parallelism:1,hashLen:32};try{const n=await argon2.hash(c);const o=crypto.createDecipheriv("aes-256-ctr",Buffer.from(n.hash.buffer),t.iv);const s=Buffer.concat([o.update(t.ciphertext),o.final()]);return s.toString("hex").toUpperCase()}catch(t){throw t}}async function signBlock(n,o){return new Promise(async(t,e)=>{try{n=toUint8Array(n);o=toUint8Array(o);const r=secp256k1.ecdsaSign(n,o);const c=Buffer.from(r.signature,"hex").toString("hex")+Buffer.from([r.recid],"hex").toString("hex");t(c)}catch(t){e(t)}})}async function validateAccount(o,t,e){const s=await decryptAccount(o,t,e);return new Promise(function(t,e){try{const r=Buffer.from(s.toUpperCase(),"hex");const c=secp256k1.publicKeyCreate(r,false).slice(1);const n=Buffer.from(c,"hex").toString("hex").toUpperCase();if(encodeAccount(n)===getAddress(o.account)){t(true)}else{t(false)}}catch(t){e(t)}})}class Accounts{constructor(t){this.costNum=16*1024}create(t){if(t!==undefined)return createAccount(t,this.costNum)}async createWithoutMnemonic(t){if(t){return await createAccountWithoutPassword(false,t,0)}}async importWithMnemonic(t,e,r=0){if(t&&e){return await importAccountWithMnemonic(t,e,r)}}async createByPrivate(t,e){if(!e){return"Private key not found"}return await createAccount(t,this.costNum,e)}async getAccountByPrivate(n){if(!n){return"Private key not found"}n=Buffer.from(n.toUpperCase(),"hex");return new Promise(function(t,e){try{const r=secp256k1.publicKeyCreate(n,false).slice(1);const c=Buffer.from(r,"hex").toString("hex").toUpperCase();t(encodeAccount(c))}catch(t){e(t)}})}validateAccount(t,e){return validateAccount(t,e,this.costNum)}async decrypt(t,e){const r=await validateAccount(t,e,this.costNum);if(r){return decryptAccount(t,e,this.costNum)}else{throw new Error("Parameter (password)'s value invalid")}}async sign(t,e){return await signBlock(t,e)}}module.exports=Accounts;