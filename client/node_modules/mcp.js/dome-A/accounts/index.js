"use strict";const crypto=require("crypto");const argon2=require("argon2-wasm-pro");const edPro=require("ed25519-wasm-pro");const bs58check=require("bs58check");const bip39=require("bip39");const HDKey=require("hdkey");function encodeAccount(e){if(e==="0000000000000000000000000000000000000000000000000000000000000000"){return"mcp_zero_address"}const t=Buffer.from([1]);const r=Buffer.concat([t,e]);return"mcp"+bs58check.encode(r)}async function importAccountWithMnemonic(e,t){if(typeof e!="string"){throw new Error(`Unexpected type at first args. Need string but get ${typeof e}.`)}return await createAccountWithoutPassword(e,t)}async function createAccountWithoutPassword(e,t){const o=e||bip39.generateMnemonic(128);const r=await bip39.mnemonicToSeed(o,"");const c=HDKey.fromMasterSeed(r);const n=c.derive(t);const a=n.deriveChild(0).deriveChild(0);const i=a.privateKey;return new Promise(function(c,t){try{edPro.ready(function(){const e=edPro.createKeyPair(i);const t=Buffer.from(e.publicKey.buffer);const r={account:encodeAccount(t),private_key:i.toString("hex").toUpperCase(),mnemonic:o};c(r)})}catch(e){t(e)}}).catch(e=>{throw e})}async function createAccount(e,t,o){const n=crypto.randomBytes(16);const a=crypto.randomBytes(16);o=o?Buffer.from(o.toUpperCase(),"hex"):crypto.randomBytes(32);const r={pass:e.toString(),salt:n,type:argon2.argon2id,time:1,mem:t,parallelism:1,hashLen:32};try{const i=await argon2.hash(r);const c=crypto.createCipheriv("aes-256-ctr",Buffer.from(i.hash.buffer),a);const s=Buffer.concat([c.update(o),c.final()]);const u=new Promise(function(c,t){try{edPro.ready(function(){const e=edPro.createKeyPair(o);const t=Buffer.from(e.publicKey.buffer);crypto.randomFillSync(Buffer.from(i.hash.buffer));crypto.randomFillSync(o);const r={account:encodeAccount(t),kdf_salt:n.toString("hex").toUpperCase(),iv:a.toString("hex").toUpperCase(),ciphertext:s.toString("hex").toUpperCase()};c(r)})}catch(e){t(e)}});return u}catch(e){throw e}}async function decryptAccount(e,t,r){e.kdf_salt=Buffer.from(e.kdf_salt,"hex");e.iv=Buffer.from(e.iv,"hex");e.ciphertext=Buffer.from(e.ciphertext,"hex");const c={pass:t.toString(),salt:e.kdf_salt,type:argon2.argon2id,time:1,mem:r,parallelism:1,hashLen:32};try{const o=await argon2.hash(c);const n=crypto.createDecipheriv("aes-256-ctr",Buffer.from(o.hash.buffer),e.iv);const a=Buffer.concat([n.update(e.ciphertext),n.final()]);return a.toString("hex").toUpperCase()}catch(e){throw e}}async function signBlock(o,n){return new Promise(function(c,t){try{edPro.ready(function(){o=Buffer.from(o,"hex");n=Buffer.from(n,"hex");const e=edPro.createKeyPair(n);const t=edPro.sign(o,e.publicKey,e.secretKey);const r=Buffer.from(t.buffer).toString("hex").toUpperCase();c(r)})}catch(e){t(e)}})}async function validateAccount(c,e,t){const o=await decryptAccount(c,e,t);return new Promise(function(r,t){try{edPro.ready(function(){const e=edPro.createKeyPair(Buffer.from(o,"hex"));const t=Buffer.from(e.publicKey.buffer);if(encodeAccount(t)===c.account){r(true)}else{r(false)}})}catch(e){t(e)}})}async function decryptAndSign(e,t,r){}class Accounts{constructor(e){this.costNum=16*1024}create(e){if(e!==undefined)return createAccount(e,this.costNum)}async createWithoutMnemonic(e){if(e){return await createAccountWithoutPassword(false,e)}}async importWithMnemonic(e,t){if(e&&t){return await importAccountWithMnemonic(e,t)}}async createByPrivate(e,t){if(!t){return"Private key not found"}return await createAccount(e,this.costNum,t)}async getAccountByPrivate(c){if(!c){return"Private key not found"}c=Buffer.from(c.toUpperCase(),"hex");return new Promise(function(r,t){try{edPro.ready(function(){const e=edPro.createKeyPair(c);const t=Buffer.from(e.publicKey.buffer);r(encodeAccount(t))})}catch(e){t(e)}})}validateAccount(e,t){return validateAccount(e,t,this.costNum)}async decrypt(e,t){const r=await validateAccount(e,t,this.costNum);if(r){return decryptAccount(e,t,this.costNum)}else{throw new Error("Parameter (password)'s value invalid")}}async sign(e,t){return await signBlock(e,t)}}module.exports=Accounts;