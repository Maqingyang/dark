const AbiCoder=require("./abi-coder/index");const compile=require("./compile/crc20");function parse(t,n){let o="";if(!n){const s=t.functionName;const i=n||compile.abi;const c=t.args?t.args:[];for(const u in i){let e;if(i[u].name===undefined){e=i[u].type}else{e=i[u].name}if(e===s){o=i[u];break}}t.funABI=o;const p=[];if(o.inputs&&o.inputs.length){for(let e=0;e<o.inputs.length;e++){const l=o.inputs[e].type;p.push(l);if(c.length<p.length){c.push("")}}}const r=new AbiCoder;let e=r.encode(p,c);e=e.substr(0,2)==="0x"?e.substr(2):e;if(o.name==="constructor"||o.type==="constructor"){t.data=compile.contractByteCode+e}else{const a=compile.methodBytecode;t.data=a[s]+e}return t}else{o=n;const c=t.funArgs;const p=[];if(o.inputs&&o.inputs.length){for(let e=0;e<o.inputs.length;e++){const l=o.inputs[e].type;p.push(l.indexOf("tuple")===0?f(o.inputs[e]):l);if(c.length<p.length){c.push("")}}}return(new AbiCoder).encode(p,c)}function f(e){if(e&&e.type.indexOf("tuple")===0&&e.components){const t=e.components.map(e=>e.type);return`tuple(${t.join(",")})${this.extractSize(e.type)}`}return e.type}}module.exports={parse:parse};